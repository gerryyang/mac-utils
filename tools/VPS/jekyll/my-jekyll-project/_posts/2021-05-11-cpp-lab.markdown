---
layout: post
title:  "CPP Lab"
date:   2021-05-11 08:00:00 +0800
categories: [C/C++]
---

* Do not remove this line (it will not be displayed)
{:toc}

# Prepare

* 编译器对标准的支持情况：https://en.cppreference.com/w/cpp/compiler_support
* 模版实例化工具：https://cppinsights.io/
* 编译运行工具：https://wandbox.org/

查看当前环境C++版本：

```
$ ls -l /lib64/libstdc++.so.6
lrwxrwxrwx 1 root root 19 Aug 18  2020 /lib64/libstdc++.so.6 -> libstdc++.so.6.0.25
$ rpm -qf /lib64/libstdc++.so.6
libstdc++-8.3.1-5.el8.0.2.x86_64
```

# TODO

* [What every C++ programmer should know, The hard part](http://web.archive.org/web/20131210001207/http://thomas-sanchez.net/computer-sciences/2011/08/15/what-every-c-programmer-should-know-the-hard-part/)
* [Stacktrace from exception](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2370r0.html)
* https://stackoverflow.com/questions/2354784/attribute-formatprintf-1-2-for-msvc
* https://yun.weicheng.men/Book/C%2B%2B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97.pdf

* https://en.cppreference.com/w/cpp/language/initialization

* Argument-dependent lookup   https://en.cppreference.com/w/cpp/language/adl


# STL

## Map

``` cpp

#include <iostream>
#include <map>

struct S
{
    S(int i, int j) : a(i), b(j) {}
    int a;
    int b;

    // ok, use operator< to sort
    bool operator<(const S& rhs) const
    {
        if (a < rhs.a)
        {
            return true;
        }
        else if (a == rhs.a)
        {
            if (b < rhs.b)
            {
                return true;
            }
            return false;
        }
        else
        {
            return false;
        }
    }
};

// ok, use operator< to sort
bool operator<(const S& lhs, const S& rhs)
{
    if (lhs.a < rhs.a)
    {
        return true;
    }
    else if (lhs.a == rhs.a)
    {
        if (lhs.b < rhs.b)
        {
            return true;
        }
        return false;
    }
    else
    {
        return false;
    }
}

// ok
struct SCompare
{
    bool operator()(const S& lhs, const S& rhs) const
    {
        if (lhs.a < rhs.a)
        {
            return true;
        }
        else if (lhs.a == rhs.a)
        {
            if (lhs.b < rhs.b)
            {
                return true;
            }
            return false;
        }
        else
        {
            return false;
        }
    }
};

// ok
namespace std
{
template<>
struct less<S>
{
    bool operator()(const S& lhs, const S& rhs) const
    {
        if (lhs.a < rhs.a)
        {
            return true;
        }
        else if (lhs.a == rhs.a)
        {
            if (lhs.b < rhs.b)
            {
                return true;
            }
            return false;
        }
        else
        {
            return false;
        }
    }
};
}

//using Map = std::map<S, std::string, SCompare>;
using Map = std::map<S, std::string>;

int main()
{
    Map m;

    auto f1 = [](bool b) { b ? std::cout << "true\n" : std::cout << "false\n"; };

    f1(m.emplace(std::make_pair(S(1, 1), "a")).second);
    f1(m.emplace(std::make_pair(S(1, 2), "b")).second);
    f1(m.emplace(std::make_pair(S(2, 1), "c")).second);

    auto f2 = [&m]()
    {
        for (auto& n : m)
        {
            std::cout << n.second << " ";
        }
    };
    f2();

    // find 操作会对每个元素比较两次，两次比较结果都是false则认为相等
    S k(1, 2);
    auto iter = m.find(k);
    if (iter != m.end()) {
        printf("find\n");
    } else {
        printf("no find\n");
    }

    return 0;
}
/*
true
true
true
a b c
find
*/
```



# C++11

## auto

`auto`没有指定`&`时，会推导为值拷贝。例如，`auto s : vec`

``` cpp
#include <cstdio>
#include <string>
#include <vector>

int main()
{
    std::vector<std::string> vec = {"1", "2"};
    for (auto s : vec) {
      printf("%s\n", s.c_str());
    }
}
```

使用[https://cppinsights.io/](https://cppinsights.io/)翻译可以得到：

``` cpp
#include <cstdio>
#include <string>
#include <vector>

int main()
{
  std::vector<std::string> vec = std::vector<std::basic_string<char>, std::allocator<std::basic_string<char> > >{std::initializer_list<std::basic_string<char> >{std::basic_string<char>("1", std::allocator<char>()), std::basic_string<char>("2", std::allocator<char>())}, std::allocator<std::basic_string<char> >()};
  {
    std::vector<std::basic_string<char>, std::allocator<std::basic_string<char> > > & __range1 = vec;
    __gnu_cxx::__normal_iterator<std::basic_string<char> *, std::vector<std::basic_string<char>, std::allocator<std::basic_string<char> > > > __begin1 = __range1.begin();
    __gnu_cxx::__normal_iterator<std::basic_string<char> *, std::vector<std::basic_string<char>, std::allocator<std::basic_string<char> > > > __end1 = __range1.end();
    for(; __gnu_cxx::operator!=(__begin1, __end1); __begin1.operator++()) {
      std::basic_string<char> s = std::basic_string<char>(__begin1.operator*());  // 存在值拷贝
      printf("%s\n", s.c_str());
    }
    
  }
}
```

若将`auto s : vec`改为`auto& s : vec`，则会变为引用：

``` cpp
std::basic_string<char> & s = __begin1.operator*();
```


## Fixed width integer types

* int8_t/int16_t/int32_t/int64_t

signed integer type with width of exactly 8, 16, 32 and 64 bits respectively with no padding bits and using 2's complement for negative values

* uint8_t/uint16_t/uint32_t/uint64_t

unsigned integer type with width of exactly 8, 16, 32 and 64 bits respectively

* intptr_t

signed integer type capable of holding a pointer

* uintptr_t
  
unsigned integer type capable of holding a pointer

https://en.cppreference.com/w/cpp/types/integer
## lambda

``` cpp
[captures] (params) specifiers exception -> ret { body }
```

* 作用域
  + 捕获列表中的变量存在于两个作用域：lambda 表达式定义的函数作用域（用于捕获变量），以及 lambda 表达式函数体的作用域（用于使用变量）
  + 捕获变量必须是一个自动存储类型（即，非静态的局部变量）
* 捕获值和捕获引用
  + 捕获的变量默认为常量（即，捕获值），或者说 lambda 是一个常量函数（类似于常量成员函数）
  + 捕获引用，可以在 lambda 的函数体中修改对应捕获的变量
  + 使用 mutable 说明符移除 lambda 表达式的常量性。如果存在说明符，则形参列表不能省略
  + 捕获值的变量在 lambda 表达式定义的时候就已经固定下来了，而捕获引用的变量以调用 lambda 表达式前的为准
* 特殊的捕获方法
  + `[this]` 捕获`this`指针，可以使用`this`类型的成员变量和函数
  + `[=]` 捕获 lambda 表达式定义作用域的全部变量的值，包括`this`
  + `[&]` 捕获 lambda 表达式定义作用域的全部变量的引用，包括`this`

> 注意：新的C++20标准，不再支持`[=]`或`[&]`隐式捕获`this`指针了，而是提示用户显式添加`this`或者`*this`。


``` cpp
#include <iostream>

class A
{
public:
    void print() {
        std::cout << "A::print()\n";
    }
    void test() {
        auto foo = [this] {
            x = 5;
            print();
        };
        foo();
    }
private:
    int x = 0;
};

int main()
{
    int x = 5;
    // 捕获值
    auto foo = [x](int y)->int { return x * y; };
    std::cout << foo(8) << std::endl; // 40


    //auto foo2 = [x](int y)->int { ++x; return x * y; }; //  error: increment of read-only variable 'x'
    // 捕获引用
    auto foo2 = [&x](int y)->int { ++x; return x * y; };
    std::cout << foo2(8) << std::endl;  // 48

    // 使用 mutable 说明符移除 lambda 表达式的常量性
    auto foo3 = [x](int y) mutable ->int { ++x; return x * y; };
    std::cout << foo3(8) << std::endl;  // 56

    // 捕获 this 
    A a;
    a.test(); 
}
```

### lambda 表达式与仿函数（函数对象）的区别

* 使用 lambda 表达式，不需要去显式定义一个类，在快速实现功能上比较有优势 -> 让代码短小精悍且具有良好的可读性
* 使用函数对象，可以在初始化时有更丰富的操作，即，可以使用全局或静态局部变量，而非必须为局部自动变量 -> 灵活不受限制
  
### lambda 表达式原理

lambda 表达式在编译期会有编译器自动生成一个闭包类，在运行时由这个闭包类产生一个对象，称它为`闭包`。在C++中，所谓的`闭包`可以简单地理解为一个匿名且可以包含定义时作用域上下文的函数对象。

``` cpp
#include <iostream>

int main()
{
  int x = 5, y = 8;
  auto foo = [=]  { return x * y; };     
  int z = foo();
}
```

使用[https://cppinsights.io/](https://cppinsights.io/)翻译一下，生成如下代码：

``` cpp
#include <iostream>

int main()
{
  int x = 5;
  int y = 8;
    
  class __lambda_6_14
  {
    public: 
        inline /*constexpr */ int operator()() const
        {
        return x * y;
        }
    
    private: 
        int x;
        int y;
    
    public:
        __lambda_6_14(int & _x, int & _y)
            : x{_x}
            , y{_y}
        {}
    
  };
  
  __lambda_6_14 foo = __lambda_6_14{x, y};
  int z = foo.operator()();
}
```

因此，从某种程度上说，lambda 表达式是C++11提供的一种语法糖，让代码编写更加轻松。

### 性能影响

> In addition, C++ compilers optimize lambdas better than they do ordinary functions. (Page 213)

* [Are lambdas inlined like functions in C++?](https://stackoverflow.com/questions/15930755/are-lambdas-inlined-like-functions-in-c)
* [Why can lambdas be better optimized by the compiler than plain functions?](https://stackoverflow.com/questions/13722426/why-can-lambdas-be-better-optimized-by-the-compiler-than-plain-functions)

### 在STL中使用 lambda 表达式

有了 lambda 表达式后，可以直接在STL算法函数的参数列表内实现辅助函数。

``` cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
    std::vector<int> x = {1, 2, 3, 4, 5};
    std::cout << *std::find_if(x.cbegin(), x.cend(), [](int i){ return (i % 3) == 0; }) << std::endl; // 3
}
```

在 C++14 标准中，定义广义捕获。分为：
    + 简单捕获。例如，`[identifier]`，`[&identifier]`，`[this]`等
    + 初始化捕获。除了捕获 lambda 表达式定义上下文的变量，也可以捕获表达式结果，以及自定义捕获变量名

``` cpp
#include <iostream>

int main()
{
    int x = 5;
    // c++14 初始化捕获，自定义捕获变量 r
    auto foo = [r = x + 1] { return r; };
    std::cout << foo(); // 6
}
```

### 泛型 lambda 表达式 (C++14)

C++14标准让 lambda 表达式具备了模板函数的能力，称为`泛型 lambda 表达式`。虽然具备模板函数的能力，但是它的定义却用不到`template`关键字。

``` cpp
#include <iostream>

int main()
{
    auto foo = [](auto a) { return a; };
    
    int b = foo(3);
    const char* c = foo("hello");
    
    std::cout << b << " " << c << std::endl;// 3 hello
}
```

### 示例

``` cpp
#include <iostream>
#include <ctime>

int main()
{
        while (false) {
                thread_local time_t tLastTime = 0;
                time_t tNow = time(nullptr);
                if (tLastTime + 1 <= tNow) {
                        tLastTime = tNow;
                        std::cout << "tick\n";
                }
        }

        auto freq = [](int t) -> bool {
                thread_local time_t tLastTime = 0;
                time_t tNow = time(nullptr);
                if (tLastTime + t <= tNow) {
                    tLastTime = tNow;
                        return true;
                }
                return false;
        };

        while (true) {
                if (freq(1)) {
                        std::cout << "tick\n";
                }
        }

}
```

## std::hash

``` cpp
// functional header
// for hash<class template> class
#include <functional> 
#include <iostream>
#include <string>

int main()
{
    // Get the string to get its hash value
    std::string hashing = "Geeks";
 
    // Instantiation of Object
    std::hash<std::string> mystdhash;
 
    // Using operator() to get hash value
    std::cout << "String hash values: "
         << mystdhash(hashing)
         << std::endl;
    
    int hashing2 = 12345;
    std::hash<int> mystdhash2;
    std::cout << "Int hash values: "
        << mystdhash2(hashing2)
        << std::endl;    
}
/*
String hash values: 4457761756728957899
Int hash values: 12345
*/
```


https://en.cppreference.com/w/cpp/utility/hash


## std::thread

``` cpp
#include <iostream>       // std::cout
#include <thread>         // std::thread

void foo() 
{
  std::cout << "foo()\n";
}

void bar(int x)
{
  std::cout << "bar(" << x << ")\n";
}

int main() 
{
  std::thread first (foo);      // spawn new thread that calls foo()
  std::thread second (bar, 0);  // spawn new thread that calls bar(0)

  std::cout << "main, foo and bar now execute concurrently...\n";

  // synchronize threads:
  first.join();                // pauses until first finishes
  second.join();               // pauses until second finishes

  std::cout << "foo and bar completed.\n";

  return 0;
}
/*
main, foo and bar now execute concurrently...
foo()
bar(0)
foo and bar completed.
*/
```

* https://www.cplusplus.com/reference/thread/thread/

# thread_local

The `thread_local` keyword is only allowed for objects declared at namespace scope, objects declared at block scope, and static data members. It indicates that the object has thread storage duration. It can be combined with `static` or `extern` to specify internal or external linkage (except for static data members which always have external linkage), respectively, but that additional static doesn't affect the storage duration.

``` cpp
#include <iostream>

class foo
{
public:
  static thread_local int a;
};

thread_local int foo::a = 1;

int main()
{
  std::cout << foo::a; // 1
}
```

* https://en.cppreference.com/w/cpp/language/storage_duration
* https://stackoverflow.com/questions/10999131/can-you-use-thread-local-variables-inside-a-class-or-structure
* [Are C++11 thread_local variables automatically static?](https://stackoverflow.com/questions/22794382/are-c11-thread-local-variables-automatically-static)

## std::vector<T,Allocator>::shrink_to_fit

Requests the removal of unused capacity. It is a non-binding request to reduce `capacity()` to `size()`. It depends on the implementation whether the request is fulfilled. If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated.

``` cpp
#include <iostream>
#include <vector>
 
int main()
{
    std::vector<int> v;
    std::cout << "Default-constructed capacity is " << v.capacity() << '\n';
    v.resize(100);
    std::cout << "Capacity of a 100-element vector is " << v.capacity() << '\n';
    v.resize(50);
    std::cout << "Capacity after resize(50) is " << v.capacity() << '\n';
    v.shrink_to_fit();
    std::cout << "Capacity after shrink_to_fit() is " << v.capacity() << '\n';
    v.clear(); // Erases all elements from the container. After this call, size() returns zero. But capacity() is not !
    std::cout << "Capacity after clear() is " << v.capacity() << '\n';
    v.shrink_to_fit();
    std::cout << "Capacity after shrink_to_fit() is " << v.capacity() << '\n';
    for (int i = 1000; i < 1300; ++i)
        v.push_back(i);
    std::cout << "Capacity after adding 300 elements is " << v.capacity() << '\n';
    v.shrink_to_fit();
    std::cout << "Capacity after shrink_to_fit() is " << v.capacity() << '\n';
}
/*
Default-constructed capacity is 0
Capacity of a 100-element vector is 100
Capacity after resize(50) is 100
Capacity after shrink_to_fit() is 50
Capacity after clear() is 50
Capacity after shrink_to_fit() is 0
Capacity after adding 300 elements is 512
Capacity after shrink_to_fit() is 300
*/
```

* https://en.cppreference.com/w/cpp/container/vector/shrink_to_fit
## std::map<Key,T,Compare,Allocator>::emplace

``` cpp
template< class... Args >
std::pair<iterator,bool> emplace( Args&&... args );
```

Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.

``` cpp
#include <iostream>
#include <utility>
#include <string>
#include <map>
 
int main()
{
    std::map<std::string, std::string> m;
 
    // uses pair's move constructor
    m.emplace(std::make_pair(std::string("a"), std::string("a")));
 
    // uses pair's converting move constructor
    m.emplace(std::make_pair("b", "abcd"));
 
    // uses pair's template constructor
    m.emplace("d", "ddd");
 
    // uses pair's piecewise constructor
    m.emplace(std::piecewise_construct,
              std::forward_as_tuple("c"),
              std::forward_as_tuple(10, 'c'));
    // as of C++17, m.try_emplace("c", 10, 'c'); can be used
 
    for (const auto &p : m) {
        std::cout << p.first << " => " << p.second << '\n';
    }
}
/*
a => a
b => abcd
c => cccccccccc
d => ddd
*/
```

## std::enable_shared_from_this

* `std::enable_shared_from_this` allows an object `t` that is currently managed by a `std::shared_ptr` named `pt` to safely generate additional `std::shared_ptr` instances pt1, pt2, ... that all share ownership of t with `pt`.
* **Publicly inheriting** from `std::enable_shared_from_this<T>` provides the type T with a member function `shared_from_this`. If an object t of type `T` is managed by a `std::shared_ptr<T>` named `pt`, then calling `T::shared_from_this` will return a new `std::shared_ptr<T>` that shares ownership of t with `pt`.

``` cpp
#include <memory>
#include <iostream>
 
struct Good: public std::enable_shared_from_this<Good> // note: public inheritance
{
    std::shared_ptr<Good> getptr() {
        return shared_from_this();
    }
};
 
struct Bad
{
    std::shared_ptr<Bad> getptr() {
        return std::shared_ptr<Bad>(this);
    }
    ~Bad() { std::cout << "Bad::~Bad() called\n"; }
};
 
int main()
{
    // Good: the two shared_ptr's share the same object
    std::shared_ptr<Good> gp1 = std::make_shared<Good>();
    std::shared_ptr<Good> gp2 = gp1->getptr();
    std::cout << "gp2.use_count() = " << gp2.use_count() << '\n';
 
    // Bad: shared_from_this is called without having std::shared_ptr owning the caller 
    try {
        Good not_so_good;
        std::shared_ptr<Good> gp1 = not_so_good.getptr();
    } catch(std::bad_weak_ptr& e) {
        // undefined behavior (until C++17) and std::bad_weak_ptr thrown (since C++17)
        std::cout << e.what() << '\n';    
    }
 
    // Bad, each shared_ptr thinks it's the only owner of the object
    std::shared_ptr<Bad> bp1 = std::make_shared<Bad>();
    std::shared_ptr<Bad> bp2 = bp1->getptr();
    std::cout << "bp2.use_count() = " << bp2.use_count() << '\n';
    
} // UB: double-delete of Bad
/*
gp2.use_count() = 2
bad_weak_ptr
bp2.use_count() = 1
Bad::~Bad() called
Bad::~Bad() called
*** glibc detected *** ./test: double free or corruption
*/
```

https://en.cppreference.com/w/cpp/memory/enable_shared_from_this

## std::this_thread::sleep_for

``` cpp
#include <iostream>
#include <chrono>
#include <thread>
 
int main()
{
    std::cout << "Hello waiter\n" << std::flush;
    auto start = std::chrono::high_resolution_clock::now();

    //using namespace std::chrono_literals;
    //std::this_thread::sleep_for(2000ms); // 2000ms for C++14

    std::chrono::nanoseconds ns(500 * 1000 * 1000);
    std::this_thread::sleep_for(ns);

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double, std::milli> elapsed = end-start;
    std::cout << "Waited " << elapsed.count() << " ms\n";
}
```
* https://en.cppreference.com/w/cpp/thread/sleep_for
* https://en.cppreference.com/w/cpp/chrono/duration

## std::mem_fn

* Function template `std::mem_fn` generates wrapper objects for pointers to members, which can store, copy, and invoke a pointer to member. Both references and pointers (including smart pointers) to an object can be used when invoking a `std::mem_fn`.

``` cpp
#include <functional>
#include <iostream>
 
struct Foo {
    void display_greeting() {
        std::cout << "Hello, world.\n";
    }
    void display_number(int i) {
        std::cout << "number: " << i << '\n';
    }
    int data = 7;
};
 
int main() {
    Foo f;
 
    auto greet = std::mem_fn(&Foo::display_greeting);
    greet(f);
 
    auto print_num = std::mem_fn(&Foo::display_number);
    print_num(f, 42);
 
    auto access_data = std::mem_fn(&Foo::data);
    std::cout << "data: " << access_data(f) << '\n';
}
```

* https://en.cppreference.com/w/cpp/utility/functional/mem_fn

## std::uniform_int_distribution

* Produces random integer values `i`, uniformly distributed on the closed interval `[a, b]`, that is, distributed according to the discrete probability function `P(i|a,b) = 1/(b - a + 1)` 

``` cpp
#include <random>
#include <iostream>
 
int main()
{
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> distrib(1, 6);
 
    for (int n=0; n<10; ++n)
        //Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6]
        std::cout << distrib(gen) << ' ';
    std::cout << '\n';
}
/*
3 6 5 6 1 2 2 4 3 3 
*/
```
* https://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution

## std::bind

The function template `bind` generates a forwarding call wrapper for `f`. Calling this wrapper is equivalent to invoking `f` with some of its arguments bound to args.

* `f`	-	[Callable object](https://en.cppreference.com/w/cpp/named_req/Callable) (`function object`, `pointer to function`, `reference to function`, `pointer to member function`, or `pointer to data member`) that will be bound to some arguments
* `args`	-	list of arguments to bind, with the unbound arguments replaced by the placeholders `_1`, `_2`, `_3`... of namespace `std::placeholders`
* As described in `Callable`, when invoking a `pointer to non-static member function` or `pointer to non-static data member`, **the first argument has to be a reference or pointer (including, possibly, smart pointer such as std::shared_ptr and std::unique_ptr) to an object** whose member will be accessed.
* The arguments to bind are **copied or moved, and are never passed by reference unless wrapped in `std::ref` or `std::cref`**.
* Duplicate placeholders in the same bind expression (multiple `_1`'s for example) are allowed, but the results are only well defined if the corresponding argument (u1) is an `lvalue` or `non-movable rvalue`.

``` cpp
#include <random>
#include <iostream>
#include <memory>
#include <functional>
 
void f(int n1, int n2, int n3, const int& n4, int n5)
{
    std::cout << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << '\n';
}

int g(int n1)
{
    return n1;
}
 
struct Foo {
    void print_sum(int n1, int n2)
    {
        std::cout << n1+n2 << '\n';
    }
    int data = 10;
};

int main()
{
    using namespace std::placeholders;  // for _1, _2, _3...
 
    std::cout << "demonstrates argument reordering and pass-by-reference:\n";
    int n = 7;
    // (_1 and _2 are from std::placeholders, and represent future
    // arguments that will be passed to f1)
    auto f1 = std::bind(f, _2, 42, _1, std::cref(n), n);
    n = 10;
    f1(1, 2, 1001); // 1 is bound by _1, 2 is bound by _2, 1001 is unused
                    // makes a call to f(2, 42, 1, n, 7)
    
    std::cout << "achieving the same effect using a lambda:\n";
    auto lambda = [ncref=std::cref(n), n=n](auto a, auto b, auto /*unused*/) {
        f(b, 42, a, ncref, n);
    };
    lambda(1, 2, 1001); // same as a call to f1(1, 2, 1001)
    
    std::cout << "nested bind subexpressions share the placeholders:\n";
    auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);
    f2(10, 11, 12); // makes a call to f(12, g(12), 12, 4, 5);
    
    std::cout << "bind to a pointer to member function:\n";
    Foo foo;
    auto f3 = std::bind(&Foo::print_sum, &foo, 95, _1);
    f3(5);
    
    std::cout << "bind to a pointer to data member:\n";
    auto f4 = std::bind(&Foo::data, _1);
    std::cout << f4(foo) << '\n';
    
    std::cout << "use smart pointers to call members of the referenced objects:\n";
    std::cout << f4(std::make_shared<Foo>(foo)) << ' '
              << f4(std::make_unique<Foo>(foo)) << '\n';
}
/*
demonstrates argument reordering and pass-by-reference:
2 42 1 10 7
achieving the same effect using a lambda:
2 42 1 10 10
nested bind subexpressions share the placeholders:
12 12 12 4 5
bind to a pointer to member function:
100
bind to a pointer to data member:
10
use smart pointers to call members of the referenced objects:
10 10
*/
```

* https://en.cppreference.com/w/cpp/utility/functional/bind

## override specifier (覆盖)

Specifies that a virtual function overrides another virtual function.

The override keyword serves two purposes:

1. It shows the reader of the code that "this is a virtual method, that is overriding a virtual method of the base class."
2. The compiler also knows that it's an override, so it can "check" that you are not altering/adding new methods that you think are overrides.

``` cpp
class base
{
  public:
    virtual int foo(float x) = 0; 
};
class derived: public base
{
   public:
     int foo(float x) override { ... } // OK
}
class derived2: public base
{
   public:
     int foo(int x) override { ... } // ERROR
};
```

In derived2 the compiler will issue an error for "changing the type". Without override, at most the compiler would give a warning for "you are hiding virtual method by same name".

* https://en.cppreference.com/w/cpp/language/override
* https://stackoverflow.com/questions/18198314/what-is-the-override-keyword-in-c-used-for


## std::abort

Causes abnormal program termination unless `SIGABRT` is being caught by a signal handler passed to `std::signal` and the handler does not return.

``` cpp
#include <csignal>
#include <iostream>
#include <cstdlib>
 
class Tester {
public:
    Tester()  { std::cout << "Tester ctor\n"; }
    ~Tester() { std::cout << "Tester dtor\n"; }
};
 
Tester static_tester; // Destructor not called
 
void signal_handler(int signal) 
{
    if (signal == SIGABRT) {
        std::cerr << "SIGABRT received\n";
    } else {
        std::cerr << "Unexpected signal " << signal << " received\n";
    }
    std::_Exit(EXIT_FAILURE);
}
 
int main()
{
    Tester automatic_tester; // Destructor not called
 
    // Setup handler
    auto previous_handler = std::signal(SIGABRT, signal_handler);
    if (previous_handler == SIG_ERR) {
        std::cerr << "Setup failed\n";
        return EXIT_FAILURE;
    }
 
    std::abort();  // Raise SIGABRT
    std::cout << "This code is unreachable\n";
}
/*
Tester ctor
Tester ctor
SIGABRT received
*/
```

## std::is_class

Checks whether T is a non-union class type. Provides the member constant value which is equal to true, if T is a class type (but not union). Otherwise, value is equal to false.

[How does this implementation of std::is_class work?](https://stackoverflow.com/questions/35213658/how-does-this-implementation-of-stdis-class-work)

``` cpp
#include <iostream>
#include <type_traits>
 
struct A {};
 
class B {};
 
enum class C {};
 
union D { class E {}; };
static_assert(not std::is_class_v<D>);
 
int main() 
{
    std::cout << std::boolalpha;
    std::cout << std::is_class<A>::value << '\n';
    std::cout << std::is_class_v<B> << '\n';         // C++17 helper
    std::cout << std::is_class<C>::value << '\n';
    std::cout << std::is_class_v<int> << '\n';
}
/*
true
true
false
false
*/
```

## std::is_union

Checks whether T is a union type. Provides the member constant value, which is equal to true if T is a union type. Otherwise, value is equal to false.

``` cpp
#include <iostream>
#include <type_traits>
 
struct A {};
 
typedef union {
    int a;
    float b;
} B;
 
struct C {
    B d;
};
 
int main() 
{
    std::cout << std::boolalpha;
    std::cout << std::is_union<A>::value << '\n';
    std::cout << std::is_union<B>::value << '\n';
    std::cout << std::is_union<C>::value << '\n';
    std::cout << std::is_union<int>::value << '\n';
}
/*
false
true
false
false
*/
```


# C++14

## std::for_each

``` cpp
#include <map>
#include <algorithm>

int main()
{
    std::map<int, int> m { {1,1}, {2,2}, {3,3} };
    std::cout << m.size() << std::endl; // 3
    
    for (auto cur = m.begin(); cur != m.end();) {
        
        if (cur->first == 1 || cur->first == 3) {
            cur = m.erase(cur);
        } else {
            ++cur;
        }
    }
    std::cout << m.size() << std::endl; // 1
    std::for_each(m.begin(), m.end(), [](const auto& pair) {std::cout << pair.first << std::endl;}); // 2
}
```

* https://en.cppreference.com/w/cpp/algorithm/for_each

## Integer literal (1'000'000)

``` cpp
// This feature is introduced since C++14. It uses single quote (') as digit separator
int i = 1'000'000;
```

* https://en.cppreference.com/w/cpp/language/integer_literal

# C++17

## std::basic_string_view

A typical implementation holds only two members: a pointer to constant CharT and a size. Several typedefs for common character types are provided:

``` cpp
// std::basic_string_view<char> == std::string_view
template<
    class CharT,
    class Traits = std::char_traits<CharT>
> class basic_string_view;
```

It is the programmer's responsibility to ensure that std::string_view does not outlive the pointed-to character array:

``` cpp
std::string_view good{"a string literal"};
  // "Good" case: `good` points to a static array (string literals are usually
  // resided in persistent data segments).
 
std::string_view bad{"a temporary string"s}; 
  // "Bad" case: `bad` holds a dangling pointer since the std::string temporary,
  // created by std::operator""s, will be destroyed at the end of the statement.
```

``` cpp
#include <iostream>
#include <string>
#include <string_view>
#include <iomanip> // std::quoted
 
int main()
{ 
    char array[3] = {'B', 'a', 'r'};
    
    // constexpr basic_string_view( const CharT* s, size_type count )
    std::string_view array_v(array, std::size(array));
    std::cout << "array_v: " << std::quoted( array_v ) << '\n';
 
    std::string cppstr = "Foo";
    
    // constexpr basic_string_view( const CharT* s )
    std::string_view cppstr_v(cppstr); 
    std::cout << "cppstr_v: " << std::quoted( cppstr_v ) << '\n';
}
/*
array_v: "Bar"
cppstr_v: "Foo"
*/
```

* https://en.cppreference.com/w/cpp/string/basic_string_view

## maybe_unused

``` cpp
#include <cassert>
 
[[maybe_unused]] void f([[maybe_unused]] bool thing1,
                        [[maybe_unused]] bool thing2)
{
   [[maybe_unused]] bool b = thing1 && thing2;
   assert(b); // in release mode, assert is compiled out, and b is unused
              // no warning because it is declared [[maybe_unused]]
} // parameters thing1 and thing2 are not used, no warning
 
int main() {;}
```

* https://en.cppreference.com/w/cpp/language/attributes/maybe_unused


# C++20

## std::source_location

The `source_location` class represents certain information about the source code, such as file names, line numbers, and function names. Previously, functions that desire to obtain this information about the call site (for logging, testing, or debugging purposes) must use macros so that predefined macros like `__LINE__` and` __FILE__` are expanded in the context of the caller. The source_location class provides a better alternative.

gcc 11.1.0

``` cpp
#include <iostream>
#include <string_view>
#include <source_location>
 
void log(const std::string_view message,
         const std::source_location location = 
               std::source_location::current())
{
    std::cout << "file: "
              << location.file_name() << "("
              << location.line() << ":"
              << location.column() << ") `"
              << location.function_name() << "`: "
              << message << '\n';
}
 
template <typename T> void fun(T x)
{
    log(x);
}
 
int main(int, char*[])
{
    log("Hello world!");
    fun("Hello C++20!");
}
/*
file: prog.cc(24:8) `int main(int, char**)`: Hello world!
file: prog.cc(19:8) `void fun(T) [with T = const char*]`: Hello C++20!
*/
```

* https://en.cppreference.com/w/cpp/utility/source_location

## Text formatting

``` cpp
#include <format>
#include <iostream>
#include <string>
#include <string_view>
 
template <typename... Args>
std::string dyna_print(std::string_view rt_fmt_str, Args&&... args) {
    return std::vformat(rt_fmt_str, std::make_format_args(args...));
}
 
int main() {
    std::cout << std::format("Hello {}!\n", "world");
 
    std::string fmt;
    for (int i{}; i != 3; ++i) {
        fmt += "{} "; // constructs the formatting string
        std::cout << fmt << " : ";
        std::cout << dyna_print(fmt, "alpha", 'Z', 3.14, "unused");
        std::cout << '\n';
    }
}
/*
Hello world!
{}  : alpha 
{} {}  : alpha Z 
{} {} {}  : alpha Z 3.14
*/
```

* https://en.cppreference.com/w/cpp/utility/format
* https://github.com/fmtlib/fmt


# Clang-Format Style Options

https://clang.llvm.org/docs/ClangFormatStyleOptions.html

	
# Others


## Alignment and Bit Fields

* [测试代码](https://github.com/gerryyang/mac-utils/tree/master/programing/cpp/alignment)
* [pragma pack effect](https://stackoverflow.com/questions/3318410/pragma-pack-effect)
* [C - Bit Fields](https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm)


## offsetof (macro)

``` cpp
#define offsetof(type, member) /*implementation-defined*/
```

``` cpp
#include <iostream>
#include <cstddef>

struct S {
    char   m0;
    double m1;
    short  m2;
    char   m3;
//  private: int z; // warning: 'S' is a non-standard-layout type
};
int main()
{
    std::cout
        << "offset of char   m0 = " << offsetof(S, m0) << '\n'
        << "offset of double m1 = " << offsetof(S, m1) << '\n'
        << "offset of short  m2 = " << offsetof(S, m2) << '\n'
        << "offset of char   m3 = " << offsetof(S, m3) << '\n';
}
/*
offset of char   m0 = 0
offset of double m1 = 8
offset of short  m2 = 16
offset of char   m3 = 18
*/
```

https://en.cppreference.com/w/cpp/types/offsetof

## malloc_trim

* [malloc_trim](https://man7.org/linux/man-pages/man3/malloc_trim.3.html) function attempts to release free memory from the heap (by calling `sbrk(2)` or `madvise(2)` with suitable arguments). This function is a GNU extension.

## operator<<

``` cpp
#include <iostream>
#include <string>
#include <vector>

template<typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec)
{
    for (auto& el : vec)
    {
        os << el << ' ';
    }
    return os;
}

int main()
{
    std::vector<std::string> vec = {
        "Hello", "from", "GCC", __VERSION__, "!" 
    };
    std::cout << vec << std::endl;
}
```

