---
layout: post
title:  "CPP Lab"
date:   2021-05-11 08:00:00 +0800
categories: [C/C++]
---

* Do not remove this line (it will not be displayed)
{:toc}


* 编译器对标准的支持情况：https://en.cppreference.com/w/cpp/compiler_support
* 模版实例化工具：https://cppinsights.io/
* 编译运行工具：https://wandbox.org/


# Alignment and Bit Fields

* [测试代码](https://github.com/gerryyang/mac-utils/tree/master/programing/cpp/alignment)
* [pragma pack effect](https://stackoverflow.com/questions/3318410/pragma-pack-effect)
* [C - Bit Fields](https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm)

# Template

## SFINAE

``` cpp
#include <iostream>

// has_member_gc用来判断一个类T是否定义了成员函数void __gc()
template<class T>
struct has_member_gc {
  // 声明辅助模板类sfinae，它接受两个模板参数：U以及U的成员函数指针常量（签名为void()）
  template<class U, void (U::*)()>
  struct sfinae;

  // 声明辅助模板函数test，它有一个模板参数U，它有一个函数参数叫unused，unused的类型是sfinae<U, &U::__gc>*，返回类型char
  template<class U>
  static char test(sfinae<U, &U::__gc>* unused);

  // 声明辅助模板函数test的一个重载版本，它有一个模板参数，函数参数是可变参数，返回类型int
  template<class>
  static int test(...);

  // 核心的判断，考虑函数的调用：test<T>(nullptr)
  // test函数有两个重载，根据重载规则，可变参数的重载优先级是最低的，所以会优先考虑第一个重载版本
  // 编译器会先试着实例化sfinae<T, &T::__gc>，这里分两种情况考虑：
  // 1、如果T定义了成员函数void __gc()
  //   则sfinae<T, &T::__gc>是一个合法的类型，最终会调用test的第一个版本，所以test的返回类型是char
  //   这个时候，sizeof(返回类型) == sizeof(char)，value的值为true
  // 2、否则
  //   sfinae<T, &T::__gc>不是一个合法的类型，根据SFINAE规则，编译器不会报错，继续去找下一个重载版本
  //   此时会调用到test(...)，返回类型是int
  //   这个时候，sizeof(返回类型) != sizeof(char)，value的值为false
  static constexpr bool value = sizeof(test<T>(nullptr)) == sizeof(char);
};

struct foo {
  void __gc() {}
};

int main()
{
	std::cout << has_member_gc<foo>::value << " ";
	std::cout << has_member_gc<int>::value;
}
```

# C++11

## std::this_thread::sleep_for

``` cpp
#include <iostream>
#include <chrono>
#include <thread>
 
int main()
{
    using namespace std::chrono_literals;
    std::cout << "Hello waiter\n" << std::flush;
    auto start = std::chrono::high_resolution_clock::now();

    //std::this_thread::sleep_for(2000ms); // 2000ms for C++14

    std::chrono::nanoseconds ns(500 * 1000 * 1000);
    std::this_thread::sleep_for(ns);

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double, std::milli> elapsed = end-start;
    std::cout << "Waited " << elapsed.count() << " ms\n";
}
```
* https://en.cppreference.com/w/cpp/thread/sleep_for
* https://en.cppreference.com/w/cpp/chrono/duration

## std::mem_fn

* Function template `std::mem_fn` generates wrapper objects for pointers to members, which can store, copy, and invoke a pointer to member. Both references and pointers (including smart pointers) to an object can be used when invoking a `std::mem_fn`.

``` cpp
#include <functional>
#include <iostream>
 
struct Foo {
    void display_greeting() {
        std::cout << "Hello, world.\n";
    }
    void display_number(int i) {
        std::cout << "number: " << i << '\n';
    }
    int data = 7;
};
 
int main() {
    Foo f;
 
    auto greet = std::mem_fn(&Foo::display_greeting);
    greet(f);
 
    auto print_num = std::mem_fn(&Foo::display_number);
    print_num(f, 42);
 
    auto access_data = std::mem_fn(&Foo::data);
    std::cout << "data: " << access_data(f) << '\n';
}
```

* https://en.cppreference.com/w/cpp/utility/functional/mem_fn

## std::uniform_int_distribution

* Produces random integer values `i`, uniformly distributed on the closed interval `[a, b]`, that is, distributed according to the discrete probability function `P(i|a,b) = 1/(b - a + 1)` 

``` cpp
#include <random>
#include <iostream>
 
int main()
{
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> distrib(1, 6);
 
    for (int n=0; n<10; ++n)
        //Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6]
        std::cout << distrib(gen) << ' ';
    std::cout << '\n';
}
/*
3 6 5 6 1 2 2 4 3 3 
*/
```
* https://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution

## std::bind

The function template `bind` generates a forwarding call wrapper for `f`. Calling this wrapper is equivalent to invoking `f` with some of its arguments bound to args.

* `f`	-	[Callable object(https://en.cppreference.com/w/cpp/named_req/Callable) (`function object`, `pointer to function`, `reference to function`, `pointer to member function`, or `pointer to data member`) that will be bound to some arguments
* `args`	-	list of arguments to bind, with the unbound arguments replaced by the placeholders `_1`, `_2`, `_3`... of namespace `std::placeholders`
* As described in `Callable`, when invoking a `pointer to non-static member function` or `pointer to non-static data member`, **the first argument has to be a reference or pointer (including, possibly, smart pointer such as std::shared_ptr and std::unique_ptr) to an object** whose member will be accessed.
* The arguments to bind are **copied or moved, and are never passed by reference unless wrapped in `std::ref` or `std::cref`**.
* Duplicate placeholders in the same bind expression (multiple `_1`'s for example) are allowed, but the results are only well defined if the corresponding argument (u1) is an `lvalue` or `non-movable rvalue`.

``` cpp
#include <random>
#include <iostream>
#include <memory>
#include <functional>
 
void f(int n1, int n2, int n3, const int& n4, int n5)
{
    std::cout << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << '\n';
}

int g(int n1)
{
    return n1;
}
 
struct Foo {
    void print_sum(int n1, int n2)
    {
        std::cout << n1+n2 << '\n';
    }
    int data = 10;
};

int main()
{
    using namespace std::placeholders;  // for _1, _2, _3...
 
    std::cout << "demonstrates argument reordering and pass-by-reference:\n";
    int n = 7;
    // (_1 and _2 are from std::placeholders, and represent future
    // arguments that will be passed to f1)
    auto f1 = std::bind(f, _2, 42, _1, std::cref(n), n);
    n = 10;
    f1(1, 2, 1001); // 1 is bound by _1, 2 is bound by _2, 1001 is unused
                    // makes a call to f(2, 42, 1, n, 7)
    
    std::cout << "achieving the same effect using a lambda:\n";
    auto lambda = [ncref=std::cref(n), n=n](auto a, auto b, auto /*unused*/) {
        f(b, 42, a, ncref, n);
    };
    lambda(1, 2, 1001); // same as a call to f1(1, 2, 1001)
    
    std::cout << "nested bind subexpressions share the placeholders:\n";
    auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);
    f2(10, 11, 12); // makes a call to f(12, g(12), 12, 4, 5);
    
    std::cout << "bind to a pointer to member function:\n";
    Foo foo;
    auto f3 = std::bind(&Foo::print_sum, &foo, 95, _1);
    f3(5);
    
    std::cout << "bind to a pointer to data member:\n";
    auto f4 = std::bind(&Foo::data, _1);
    std::cout << f4(foo) << '\n';
    
    std::cout << "use smart pointers to call members of the referenced objects:\n";
    std::cout << f4(std::make_shared<Foo>(foo)) << ' '
              << f4(std::make_unique<Foo>(foo)) << '\n';
}
/*
demonstrates argument reordering and pass-by-reference:
2 42 1 10 7
achieving the same effect using a lambda:
2 42 1 10 10
nested bind subexpressions share the placeholders:
12 12 12 4 5
bind to a pointer to member function:
100
bind to a pointer to data member:
10
use smart pointers to call members of the referenced objects:
10 10
*/
```

* https://en.cppreference.com/w/cpp/utility/functional/bind

## override specifier

Specifies that a virtual function overrides another virtual function.

The override keyword serves two purposes:

1. It shows the reader of the code that "this is a virtual method, that is overriding a virtual method of the base class."
2. The compiler also knows that it's an override, so it can "check" that you are not altering/adding new methods that you think are overrides.

``` cpp
class base
{
  public:
    virtual int foo(float x) = 0; 
};
class derived: public base
{
   public:
     int foo(float x) override { ... } // OK
}
class derived2: public base
{
   public:
     int foo(int x) override { ... } // ERROR
};
```

In derived2 the compiler will issue an error for "changing the type". Without override, at most the compiler would give a warning for "you are hiding virtual method by same name".

* https://en.cppreference.com/w/cpp/language/override
* https://stackoverflow.com/questions/18198314/what-is-the-override-keyword-in-c-used-for

## Variadic templates


* The **ellipsis** (`...`) operator has **two roles**. 
    + When it occurs to the **left** of the name of a parameter, it declares a **parameter pack**. Using the parameter pack, the user can bind **zero or more arguments** to the variadic template parameters. Parameter packs can also be used for non-type parameters. 
    + By contrast, when the ellipsis operator occurs to the **right** of a template or function call argument, **it unpacks the parameter packs into separate arguments**, like the `args...` in the body of `printf` below. 
* In practice, the use of an **ellipsis** operator in the code causes the whole expression that precedes the ellipsis to be repeated for every subsequent argument unpacked from the argument pack, with the expressions separated by commas.
* The use of **variadic templates** is often **recursive**. The variadic parameters themselves are not readily available to the implementation of a function or class. Therefore, the typical mechanism for defining something like a C++11 variadic `printf` replacement would be as follows:

``` cpp
#include <iostream>
#include <vector>
#include <type_traits>

void func_impl(std::vector<std::string> &str_vec)
{
    for (auto& item: str_vec) {
        std::cout << item << " ";
    }
    std::cout << "\nTODO";
}

static void pack_helper(std::vector<std::string> &str_vec)
{
}

template<typename... Args>
void pack_helper(std::vector<std::string> &str_vec, const std::string& str, const Args&... args)
{
    str_vec.push_back(str);
    pack_helper(str_vec, args ...);
}

// recursive
template<typename... Args>
void func(const std::string& str, const Args& ... args)
{
    std::vector<std::string> str_vec;
    pack_helper(str_vec, str, args...);
    func_impl(str_vec);
}

int main()
{
    func("1", "2", "a");
}
```

* https://en.wikipedia.org/wiki/Variadic_template
* https://www.ibm.com/docs/en/zos/2.4.0?topic=only-variadic-templates-c11

## [std::is_same](https://en.cppreference.com/w/cpp/types/is_same)

``` cpp
#include <type_traits>

template< class T, class U >
struct is_same;
```

* If `T` and `U` name the same type (taking into account `const`/`volatile` qualifications), provides the member constant value equal to `true`. Otherwise value is `false`.

``` cpp
#include <iostream>
#include <type_traits>

int main()
{
     // usually true if int is 32 bit
    std::cout << std::is_same<int, std::int32_t>::value << ' ';
    // possibly true if ILP64 data model is used
    std::cout << std::is_same<int, std::int64_t>::value;
}
/*
1 0
*/
```

`is_same`的实现方式：

``` cpp
#include <iostream>

// 定义is_same模板类，它接受两个模板参数T和U，它在类内定义了一个叫value的bool静态常量字段，值总是false
template<class T, class U>
struct is_same {
  static constexpr bool value = false;
};
// 对is_same偏特化，当T和U这两个类型一样时，它在类内定义了一个叫value的bool静态常量字段，值总是true
template<class T>
struct is_same<T, T> {
  static constexpr bool value = true;
};

int main()
{
  
  // 定义一个类型别名，将is_same<int, int>绑定到Result1
  // 从模板元编程的角度来看，这里可以看作是调用了元函数is_same，输入类型int和类型int，输出类型is_same<int, int>，赋值给Result1
  using Result1 = is_same<int, int>;

  // Result1就是类型is_same<int, int>，它有一个叫value的bool静态常量字段
  // 由于is_same<int, int>的两个模板参数都是int，所以这里是偏特化后的版本，value的值是true
  std::cout << Result1::value << " ";

  // 调用元函数is_same，输入类型int和类型float，输出类型is_same<int, float>，赋值给Result2
  using Result2 = is_same<int, float>;

  // 由于is_same<int, float>的两个模板参数不一样，所以这里没有偏特化，value的值是false
  std::cout << Result2::value << " ";

}
```


## [std::remove_cv/std::remove_const/std::remove_volatile](https://en.cppreference.com/w/cpp/types/remove_cv)

* removes the topmost `const`, or the topmost `volatile`, or both, if present.

``` cpp
#include <iostream>
#include <type_traits>
 
int main() {
    typedef std::remove_cv<const int>::type type1;
    typedef std::remove_cv<volatile int>::type type2;
    typedef std::remove_cv<const volatile int>::type type3;
    typedef std::remove_cv<const volatile int*>::type type4;
    typedef std::remove_cv<int * const volatile>::type type5;
 
    std::cout << "test1 " << (std::is_same<int, type1>::value
        ? "passed" : "failed") << '\n';
    std::cout << "test2 " << (std::is_same<int, type2>::value
        ? "passed" : "failed") << '\n';
    std::cout << "test3 " << (std::is_same<int, type3>::value
        ? "passed" : "failed") << '\n';
    std::cout << "test4 " << (std::is_same<const volatile int*, type4>::value
        ? "passed" : "failed") << '\n';
    std::cout << "test5 " << (std::is_same<int*, type5>::value
        ? "passed" : "failed") << '\n';
}
/*
test1 passed
test2 passed
test3 passed
test4 passed
test5 passed
*/
```

## [std::is_pointer](https://en.cppreference.com/w/cpp/types/is_pointer)

* Checks whether `T` is a **pointer to object** or **a pointer to function** (**but not a pointer to member/member function**). Provides the member constant value which is equal to `true`, if T is a object/function pointer type. Otherwise, value is equal to `false`.

``` cpp
#include <iostream>
#include <type_traits>
 
class A {};
 
int main() 
{
    std::cout << std::boolalpha;
    std::cout << std::is_pointer<A>::value << '\n';
    std::cout << std::is_pointer<A *>::value << '\n';
    std::cout << std::is_pointer<A &>::value << '\n';
    std::cout << std::is_pointer<int>::value << '\n';
    std::cout << std::is_pointer<int *>::value << '\n';
    std::cout << std::is_pointer<int **>::value << '\n';
    std::cout << std::is_pointer<int[10]>::value << '\n';
    std::cout << std::is_pointer<std::nullptr_t>::value << '\n';
}
/*
false
true
false
false
true
true
false
false
*/
```

## std::decay

Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type T, removes cv-qualifiers, and defines the resulting type as the member typedef type.

``` cpp
#include <iostream>
#include <type_traits>
 
template <typename T, typename U>
struct decay_equiv : 
    std::is_same<typename std::decay<T>::type, U>::type 
{};
 
int main()
{
    std::cout << std::boolalpha
              << decay_equiv<int, int>::value << '\n'
              << decay_equiv<int&, int>::value << '\n'
              << decay_equiv<int&&, int>::value << '\n'
              << decay_equiv<const int&, int>::value << '\n'
              << decay_equiv<int[2], int*>::value << '\n'
              << decay_equiv<int(int), int(*)(int)>::value << '\n';
}
```

* https://stackoverflow.com/questions/25732386/what-is-stddecay-and-when-it-should-be-used

# C++17

## [Constexpr If](https://en.cppreference.com/w/cpp/language/if)

* Conditionally executes another statement. Used where code needs to be executed based on a `run-time` or `compile-time` condition.

``` cpp
#include <iostream>

template <typename T>
auto get_value(T t) {
    if constexpr (std::is_pointer_v<T>) {
        std::cout << "if constexpr\n";
        return *t; // deduces return type to int for T = int*
    }
    else {
        std::cout << "other\n";
        return t;  // deduces return type to int for T = int
    }
}

int main()
{
  	int a = 1;
    int *b = &a;
	std::cout << get_value(a) << std::endl;
    std::cout << get_value(b) << std::endl;
}
/*
other
1
if constexpr
1
*/
```

使用[cppinsights](https://cppinsights.io/)实例化后的代码：

``` cpp
#include <iostream>

template <typename T>
auto get_value(T t) {
    if constexpr (std::is_pointer_v<T>) {
        std::cout << "if constexpr\n";
        return *t; // deduces return type to int for T = int*
    }
    else {
        std::cout << "other\n";
        return t;  // deduces return type to int for T = int
    }
}

#ifdef INSIGHTS_USE_TEMPLATE
template<>
int get_value<int>(int t)
{
  if constexpr(false) {
  } else /* constexpr */ {
    std::operator<<(std::cout, "other\n");
    return t;
  } 
  
}
#endif

#ifdef INSIGHTS_USE_TEMPLATE
template<>
int get_value<int *>(int * t)
{
  if constexpr(true) {
    std::operator<<(std::cout, "if constexpr\n");
    return *t;
  } 
  
}
#endif

int main()
{
  int a = 1;
  int * b = &a;
  std::cout.operator<<(get_value(a)).operator<<(std::endl);
  std::cout.operator<<(get_value(b)).operator<<(std::endl);
}

```

# C++20

TODO


  

	
	