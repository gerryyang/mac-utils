---
layout: post
title:  "CPP Lab"
date:   2021-05-11 08:00:00 +0800
categories: [C/C++]
---

* Do not remove this line (it will not be displayed)
{:toc}

# Prepare

* 编译器对标准的支持情况：https://en.cppreference.com/w/cpp/compiler_support
* 模版实例化工具：https://cppinsights.io/
* 编译运行工具：https://wandbox.org/

查看当前环境C++版本：

```
$ ls -l /lib64/libstdc++.so.6
lrwxrwxrwx 1 root root 19 Aug 18  2020 /lib64/libstdc++.so.6 -> libstdc++.so.6.0.25
$ rpm -qf /lib64/libstdc++.so.6
libstdc++-8.3.1-5.el8.0.2.x86_64
```

# TODO

* [What every C++ programmer should know, The hard part](http://web.archive.org/web/20131210001207/http://thomas-sanchez.net/computer-sciences/2011/08/15/what-every-c-programmer-should-know-the-hard-part/)
* [Stacktrace from exception](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2370r0.html)
* https://stackoverflow.com/questions/2354784/attribute-formatprintf-1-2-for-msvc
* https://yun.weicheng.men/Book/C%2B%2B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97.pdf

* https://en.cppreference.com/w/cpp/language/initialization

* Argument-dependent lookup   https://en.cppreference.com/w/cpp/language/adl


# malloc_trim

* [malloc_trim](https://man7.org/linux/man-pages/man3/malloc_trim.3.html) function attempts to release free memory from the heap (by calling `sbrk(2)` or `madvise(2)` with suitable arguments). This function is a GNU extension.

# 虚函数表(Virtual Tables)

> “A virtual method table (VMT),…, is a mechanism used in a programming language to support dynamic dispatch.” –[Wikipedia](https://en.wikipedia.org/wiki/Virtual_method_table)

* https://pabloariasal.github.io/2017/06/10/understanding-virtual-tables/

# const_cast/dynamic_cast/static_cast/reinterpret_cast/std::dynamic_pointer_cast

* [When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?](https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used)

## [std::dynamic_pointer_cast](http://www.cplusplus.com/reference/memory/dynamic_pointer_cast/)

Dynamic cast of `shared_ptr`. Returns a copy of `sp` of the proper type with its stored pointer casted dynamically from `U*` to `T*`.

``` cpp
template <class T, class U>
shared_ptr<T> dynamic_pointer_cast (const shared_ptr<U>& sp) noexcept;
```

``` cpp
#include <iostream>
#include <memory>

struct A {
  static const char* static_type;
  const char* dynamic_type;
  A() { dynamic_type = static_type; }
};

struct B: public A {
  static const char* static_type;
  B() { dynamic_type = static_type; }
};

const char* A::static_type = "class A";
const char* B::static_type = "class B";

int main () {
  std::shared_ptr<A> foo;
  std::shared_ptr<B> bar;

  bar = std::make_shared<B>();

  foo = std::dynamic_pointer_cast<A>(bar); // 类型转换 B -> A

  std::cout << "foo's static  type: " << foo->static_type << '\n';
  std::cout << "foo's dynamic type: " << foo->dynamic_type << '\n';
  std::cout << "bar's static  type: " << bar->static_type << '\n';
  std::cout << "bar's dynamic type: " << bar->dynamic_type << '\n';
}
/*
foo's static  type: class A
foo's dynamic type: class B
bar's static  type: class B
bar's dynamic type: class B
*/
```

## [dynamic_cast conversion](https://en.cppreference.com/w/cpp/language/dynamic_cast)

Safely converts pointers and references to classes up, down, and sideways along the inheritance hierarchy.

```
A -> V
B -> V
D -> A, B

D d;       // the most derived object
A& a = d;  // upcast, dynamic_cast may be used, but unnecessary  子类 -> 父类

D& new_d = dynamic_cast<D&>(a); // downcast 父类 -> 子类

B& new_b = dynamic_cast<B&>(a); // sidecast  父类 -> 子类（另一个）
```

Syntax:

`dynamic_cast < new-type > ( expression )`		

Notes:

* A downcast can also be performed with `static_cast`, which avoids the cost of the runtime check, but it's only safe if the program can guarantee (through some other logic) that the object pointed to by expression is definitely Derived.
* Some forms of `dynamic_cast` rely on [runtime type identification (RTTI)](https://en.wikipedia.org/wiki/Run-time_type_information), that is, information about each polymorphic class in the compiled program. Compilers typically have options to disable the inclusion of this information.

``` cpp
#include <iostream>
 
struct V {
    virtual void f() {}  // must be polymorphic to use runtime-checked dynamic_cast
};
struct A : virtual V {};
struct B : virtual V {
  B(V* v, A* a) {
    // casts during construction (see the call in the constructor of D below)
    dynamic_cast<B*>(v); // well-defined: v of type V*, V base of B, results in B*
    dynamic_cast<B*>(a); // undefined behavior: a has type A*, A not a base of B
  }
};
struct D : A, B {
    D() : B(static_cast<A*>(this), this) { }
};
 
struct Base {
    virtual ~Base() {}
};
 
struct Derived: Base {
    virtual void name() {}
};
 
int main()
{
    D d; // the most derived object
    A& a = d; // upcast, dynamic_cast may be used, but unnecessary
    [[maybe_unused]]
    D& new_d = dynamic_cast<D&>(a); // downcast
    [[maybe_unused]]
    B& new_b = dynamic_cast<B&>(a); // sidecast
 
 
    Base* b1 = new Base;
    if(Derived* d = dynamic_cast<Derived*>(b1))   // error
    {
        std::cout << "downcast from b1 to d successful\n";
        d->name(); // safe to call
    }
 
    Base* b2 = new Derived;
    if(Derived* d = dynamic_cast<Derived*>(b2))    // ok
    {
        std::cout << "downcast from b2 to d successful\n";
        d->name(); // safe to call
    }
 
    delete b1;
    delete b2;
}
/*
downcast from b2 to d successful
*/
```

``` cpp
#include <iostream>
#include <memory>

class foo
{
public:
     foo() { std::cout << "foo()\n"; }
     virtual ~foo() { std::cout << "~foo()\n"; }
     virtual void f() {
        std::cout << "foo::f()\n";
    }
};

class bar
{
public:
   bar() { std::cout << "bar()\n"; }
   virtual ~bar() { std::cout << "~bar()\n"; }
   void f()  {
        std::cout << "bar::f()\n";
   }
    
   int a;
};

class xyz : public foo, public bar
{
public:
   xyz() { std::cout << "xyz()\n"; }
   virtual ~xyz() { std::cout << "~xyz()\n"; }
   void f()  {
        std::cout << "xyz::f()\n";
    }
    
   int b;
};

int main(int argc, char**argv) 
{
    bar* obj = new xyz();
    std::cout << "bar obj:" << obj << std::endl;
    obj->f();
    
    auto p1 = dynamic_cast<xyz*>(obj);   // ok
    std::cout << "xyz obj:" << p1 << std::endl;
    p1->f();
    
    auto p2 = static_cast<xyz*>(obj);    // ok
    std::cout << "xyz obj:" << p2 << std::endl;
    p2->f();
    
    auto p3 = reinterpret_cast<xyz*>(obj);        // error
    std::cout << "xyz obj:" << p3 << std::endl;
    //p3->f(); // error
    
    delete obj;

}
/*
foo()
bar()
xyz()
bar obj:0x1757018
bar::f()
xyz obj:0x1757010
xyz::f()
xyz obj:0x1757010
xyz::f()
xyz obj:0x1757018
~xyz()
~bar()
~foo()
*/
```

``` cpp
#include <iostream>     
#include <map>
#include <memory>

class A
{
public:
    A() { std::cout << "A::A()\n"; }
    virtual ~A() { std::cout << "~A::A()\n"; }
    virtual void f() { std::cout << "A::f()\n"; }
    int a;
};

class A2
{
public:
    A2() { std::cout << "A2::A2()\n"; }
    virtual ~A2() { std::cout << "~A2::A2()\n"; }
    virtual void f() { std::cout << "A2::f()\n"; }
    int a2;
};

class B : public A, public A2
{
public:
    B() { std::cout << "B::B()\n"; }
    virtual ~B() { std::cout << "~B::B()\n"; }
    void f() override { std::cout << "B::f()\n"; }
    int b;
};

struct NoSensePlaceHolder {};
constexpr static NoSensePlaceHolder NoSenseHolder{};

class Buffer
{
public:
    explicit Buffer(NoSensePlaceHolder holder) : m_size(0), m_mem_ptr(nullptr) { std::cout << "Buffer(NoSensePlaceHolder holder)\n";  }
    virtual ~Buffer() { std::cout << "~Buffer()\n"; }
    
    int m_size;
    char* m_mem_ptr;
};
using BufferPtr = std::shared_ptr<Buffer>;


template <typename ObjType>
class ObjBuffer : public Buffer
{
public:
    ObjBuffer() : Buffer(NoSenseHolder) { 
        std::cout << "ObjBuffer()\n";
        m_mem_ptr = reinterpret_cast<char*>(new ObjType());
    }
    
    explicit ObjBuffer(const std::shared_ptr<ObjType>& ref) : Buffer(NoSenseHolder) {
        std::cout << "ObjBuffer(const std::shared_ptr<ObjType>& ref)\n";
        m_obj_ptr_ref = ref;
        m_mem_ptr = reinterpret_cast<char*>(ref.get());
    }
    
    virtual ~ObjBuffer() { std::cout << "~ObjBuffer()\n"; }
    
    ObjType* Cast() { return reinterpret_cast<ObjType*>(m_mem_ptr); }

protected:
    std::shared_ptr<ObjType> m_obj_ptr_ref;
    
};

// B -> A, A2
// ObjBuffer -> Buffer
int main()
{
    auto bPtr = std::make_shared<B>();
    std::cout << "bPtr: " << bPtr.get() << std::endl;
    bPtr->f();
    
    // 类型转换 B --> ObjBuffer<B> --> Buffer
    BufferPtr buff(new ObjBuffer<B>(bPtr));
    
    // 类型转换 Buffer --> ObjBuffer<>
    
    // dynamic_cast
    //auto objbuff = dynamic_cast<ObjBuffer<A>*>(buff.get());     // error, type Buffer != ObjBuffer<A>  
    //auto objbuff = dynamic_cast<ObjBuffer<A2>*>(buff.get());    // error, type Buffer != ObjBuffer<A2>
    //auto objbuff = dynamic_cast<ObjBuffer<B>*>(buff.get());     // ok, type Buffer = ObjBuffer<B>
    
    // static_cast
    auto objbuff = static_cast<ObjBuffer<A>*>(buff.get());     // ok
    //auto objbuff = static_cast<ObjBuffer<A2>*>(buff.get());    // ok
    //auto objbuff = static_cast<ObjBuffer<B>*>(buff.get());     // ok
    
    // reinterpret_cast
    //auto objbuff = reinterpret_cast<ObjBuffer<A>*>(buff.get());   // 不安全
    //auto objbuff = reinterpret_cast<ObjBuffer<A2>*>(buff.get());  // 不安全
    //auto objbuff = reinterpret_cast<ObjBuffer<B>*>(buff.get());   // 不安全
    
    // c convert
    //auto objbuff = (ObjBuffer<A>*)(buff.get());    // ok
    //auto objbuff = (ObjBuffer<A2>*)(buff.get());   // ok
    //auto objbuff = (ObjBuffer<B>*)(buff.get());    // ok
    
  
    if (!objbuff) {
        std::cout << "objbuff is nullptr\n";
        return 1;
    }
    
    // 类型转换 ObjBuffer<> --> B
    auto origobj = objbuff->Cast();
    std::cout << "origobj: " << origobj << std::endl;
    origobj->f();
    
}
```


# 虚继承

C++指出，当derived class对象经由一个base class指针被删除，而该base class带着一个non-virtual析构函数，其结果未定义 —— 实际执行时通常发生的是，对象的derived成分没被销毁。于是造成一个诡异的“局部销毁”对象，从而导致资源泄露。

> 观点1：任何class只要带有virtual函数，都几乎确定应该也有一个virtual析构函数。

> 观点2：如果class不含virtual函数，通常表示它并不意图被用做一个base class。当class不企图被当做base class，令其析构函数为virtual往往是一个馊主意。因为，欲实现出virtual函数，对象必须携带某些信息，主要用来在运行期决定哪一个virtual函数该被调用。这份信息通常是由一个所谓vptr(virtual table pointer)指出，vptr指向一个由函数指针构成的数组，称为vtbl(virtual table)。每一个带有virtual函数的class都有一个相应的vtbl。当对象调用某一virtual函数，实际被调用的函数取决于该对象的vptr所指的那个vtbl（编译器在其中寻找合适的函数指针）。这样，如果base class内含virtual函数，那么其对象的体积会增加，在32-bits计算机体系结构中将多占用32bits（vptr大小）；而在64-bits计算机体系结构中多占用64bits（指针大小为8字节）。

> 观点3：标准库string不含任何virtual函数，但有时程序员会错误地把它当做base class。那么，当你在程序任意某处无意间将一个pointer-to-specialstring转换为一个pointer-to-string，然后将转换所得的那个string指针delete掉，则立刻被流放到”不明确行为上”。很不幸C++目前没有提供类似Java的final classes禁止派生的机制。

> 请记住
> 1. 从里向外构造（ctor），从外向里析构（dtor）
> 2. polymorphic (带多态性质) base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。
> 3. classes的设计目的如果不是作为base classes使用，或不是为了具备多态性使用，此class就不该声明virtual析构函数。

测试代码：

继承和组合：

``` cpp
#include <iostream>

class A1
{
public:
    A1() {std::cout << "A1()\n"; m_a1 = new int(1); }
    ~A1() {std::cout << "~A1()\n"; delete m_a1;}
    
private:
    int* m_a1;
};

class A2 
{
public:
    A2() {std::cout << "A2()\n"; m_a2 = new int(1); }
    virtual ~A2() {std::cout << "~A2()\n"; delete m_a2;}  
    
private:
    int* m_a2;
};

class B : public A2
{
public:
    B() {std::cout << "B()\n"; m_a = new int(1); }
    ~B() {std::cout << "~B()\n"; delete m_a;}
    
private:
    int* m_a;
    A1 m_obj;
};

int main()
{
    A2* a = new B();
    delete a;      // 当A2的析构函数为virtual类型时, 此时delete才会调用B的析构函数
}
/*
A1()
A2()
B()
~B()
~A2()
~A1()
*/
```

``` cpp
#include <iostream>

class A1
{
public:
    A1() {std::cout << "A1()\n"; m_a1 = new int(1); }
    virtual ~A1() {std::cout << "~A1()\n"; delete m_a1; } 
    
private:
    int* m_a1; 
};

class A2 : A1
{
public:
    A2() {std::cout << "A2()\n"; m_a2 = new int(1); }
    virtual ~A2() {std::cout << "~A2()\n"; delete m_a2;}
    
private:
    int* m_a2;
};

class B : public A2
{
public:
    B() {std::cout << "B()\n"; m_a = new int(1); }
    ~B() {std::cout << "~B()\n"; delete m_a;}
    
private:
    int* m_a; 
};

int main()
{
    A2* a = new B(); // A1或A2有一个析构函数为virtual才会调用B的析构函数
    delete a;
}
/*
A1()
A2()
B()
~B()
~A2()
~A1()
*/
```

多重继承：

``` cpp
#include <iostream>

class A1
{
public:
    A1() {std::cout << "A1()\n"; m_a1 = new int(1); }
    ~A1() {std::cout << "~A1()\n"; delete m_a1;}
    
private:
    int* m_a1;
};

class A2
{
public:
    A2() {std::cout << "A2()\n"; m_a2 = new int(1); }
    virtual ~A2() {std::cout << "~A2()\n"; delete m_a2;}
    
private:
    int* m_a2;
};

class B : public A1, public A2
{
public:
    B() {std::cout << "B()\n"; m_a = new int(1); }
    ~B() {std::cout << "~B()\n"; delete m_a;}
    
private:
    int* m_a;
};

int main()
{
    A2* a = new B();
    delete a;   // A2的析构函数需为virtual
}
/*
A1()
A2()
B()
~B()
~A2()
~A1()
*/
```

# I/O

``` cpp
#include <iostream>
#include <string>
#include <vector>

template<typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec)
{
    for (auto& el : vec)
    {
        os << el << ' ';
    }
    return os;
}

int main()
{
    std::vector<std::string> vec = {
        "Hello", "from", "GCC", __VERSION__, "!" 
    };
    std::cout << vec << std::endl;
}
```

# STL

## Map

``` cpp

#include <iostream>
#include <map>

struct S
{
    S(int i, int j) : a(i), b(j) {}
    int a;
    int b;

    // ok, use operator< to sort
    bool operator<(const S& rhs) const
    {
        if (a < rhs.a)
        {
            return true;
        }
        else if (a == rhs.a)
        {
            if (b < rhs.b)
            {
                return true;
            }
            return false;
        }
        else
        {
            return false;
        }
    }
};

// ok, use operator< to sort
bool operator<(const S& lhs, const S& rhs)
{
    if (lhs.a < rhs.a)
    {
        return true;
    }
    else if (lhs.a == rhs.a)
    {
        if (lhs.b < rhs.b)
        {
            return true;
        }
        return false;
    }
    else
    {
        return false;
    }
}

// ok
struct SCompare
{
    bool operator()(const S& lhs, const S& rhs) const
    {
        if (lhs.a < rhs.a)
        {
            return true;
        }
        else if (lhs.a == rhs.a)
        {
            if (lhs.b < rhs.b)
            {
                return true;
            }
            return false;
        }
        else
        {
            return false;
        }
    }
};

// ok
namespace std
{
template<>
struct less<S>
{
    bool operator()(const S& lhs, const S& rhs) const
    {
        if (lhs.a < rhs.a)
        {
            return true;
        }
        else if (lhs.a == rhs.a)
        {
            if (lhs.b < rhs.b)
            {
                return true;
            }
            return false;
        }
        else
        {
            return false;
        }
    }
};
}

//using Map = std::map<S, std::string, SCompare>;
using Map = std::map<S, std::string>;

int main()
{
    Map m;

    auto f1 = [](bool b) { b ? std::cout << "true\n" : std::cout << "false\n"; };

    f1(m.emplace(std::make_pair(S(1, 1), "a")).second);
    f1(m.emplace(std::make_pair(S(1, 2), "b")).second);
    f1(m.emplace(std::make_pair(S(2, 1), "c")).second);

    auto f2 = [&m]()
    {
        for (auto& n : m)
        {
            std::cout << n.second << " ";
        }
    };
    f2();

    return 0;
}
/*
true
true
true
a b c
*/
```


# Alignment and Bit Fields

* [测试代码](https://github.com/gerryyang/mac-utils/tree/master/programing/cpp/alignment)
* [pragma pack effect](https://stackoverflow.com/questions/3318410/pragma-pack-effect)
* [C - Bit Fields](https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm)


# offsetof

``` cpp
#include <iostream>
#include <cstddef>

struct S {
    char   m0;
    double m1;
    short  m2;
    char   m3;
//  private: int z; // warning: 'S' is a non-standard-layout type
};
int main()
{
    std::cout
        << "offset of char   m0 = " << offsetof(S, m0) << '\n'
        << "offset of double m1 = " << offsetof(S, m1) << '\n'
        << "offset of short  m2 = " << offsetof(S, m2) << '\n'
        << "offset of char   m3 = " << offsetof(S, m3) << '\n';
}
/*
offset of char   m0 = 0
offset of double m1 = 8
offset of short  m2 = 16
offset of char   m3 = 18
*/
```

https://en.cppreference.com/w/cpp/types/offsetof


# C++11

## std::thread

``` cpp
#include <iostream>       // std::cout
#include <thread>         // std::thread

void foo() 
{
  std::cout << "foo()\n";
}

void bar(int x)
{
  std::cout << "bar(" << x << ")\n";
}

int main() 
{
  std::thread first (foo);      // spawn new thread that calls foo()
  std::thread second (bar, 0);  // spawn new thread that calls bar(0)

  std::cout << "main, foo and bar now execute concurrently...\n";

  // synchronize threads:
  first.join();                // pauses until first finishes
  second.join();               // pauses until second finishes

  std::cout << "foo and bar completed.\n";

  return 0;
}
/*
main, foo and bar now execute concurrently...
foo()
bar(0)
foo and bar completed.
*/
```

* https://www.cplusplus.com/reference/thread/thread/

## std::vector<T,Allocator>::shrink_to_fit

Requests the removal of unused capacity. It is a non-binding request to reduce `capacity()` to `size()`. It depends on the implementation whether the request is fulfilled. If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated.

``` cpp
#include <iostream>
#include <vector>
 
int main()
{
    std::vector<int> v;
    std::cout << "Default-constructed capacity is " << v.capacity() << '\n';
    v.resize(100);
    std::cout << "Capacity of a 100-element vector is " << v.capacity() << '\n';
    v.resize(50);
    std::cout << "Capacity after resize(50) is " << v.capacity() << '\n';
    v.shrink_to_fit();
    std::cout << "Capacity after shrink_to_fit() is " << v.capacity() << '\n';
    v.clear(); // Erases all elements from the container. After this call, size() returns zero. But capacity() is not !
    std::cout << "Capacity after clear() is " << v.capacity() << '\n';
    v.shrink_to_fit();
    std::cout << "Capacity after shrink_to_fit() is " << v.capacity() << '\n';
    for (int i = 1000; i < 1300; ++i)
        v.push_back(i);
    std::cout << "Capacity after adding 300 elements is " << v.capacity() << '\n';
    v.shrink_to_fit();
    std::cout << "Capacity after shrink_to_fit() is " << v.capacity() << '\n';
}
/*
Default-constructed capacity is 0
Capacity of a 100-element vector is 100
Capacity after resize(50) is 100
Capacity after shrink_to_fit() is 50
Capacity after clear() is 50
Capacity after shrink_to_fit() is 0
Capacity after adding 300 elements is 512
Capacity after shrink_to_fit() is 300
*/
```

* https://en.cppreference.com/w/cpp/container/vector/shrink_to_fit
## std::map<Key,T,Compare,Allocator>::emplace

``` cpp
template< class... Args >
std::pair<iterator,bool> emplace( Args&&... args );
```

Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.

``` cpp
#include <iostream>
#include <utility>
#include <string>
#include <map>
 
int main()
{
    std::map<std::string, std::string> m;
 
    // uses pair's move constructor
    m.emplace(std::make_pair(std::string("a"), std::string("a")));
 
    // uses pair's converting move constructor
    m.emplace(std::make_pair("b", "abcd"));
 
    // uses pair's template constructor
    m.emplace("d", "ddd");
 
    // uses pair's piecewise constructor
    m.emplace(std::piecewise_construct,
              std::forward_as_tuple("c"),
              std::forward_as_tuple(10, 'c'));
    // as of C++17, m.try_emplace("c", 10, 'c'); can be used
 
    for (const auto &p : m) {
        std::cout << p.first << " => " << p.second << '\n';
    }
}
/*
a => a
b => abcd
c => cccccccccc
d => ddd
*/
```


## std::shared_ptr

`std::shared_ptr` is a smart pointer that retains shared ownership of an object through a pointer. Several shared_ptr objects may own the same object. **The object is destroyed and its memory deallocated when either of the following happens**:

* the last remaining shared_ptr owning the object is destroyed;
* the last remaining shared_ptr owning the object is assigned another pointer via `operator=` or `reset()`.

The object is destroyed using `delete-expression` or a `custom deleter` that is supplied to shared_ptr during construction.

``` cpp
// Constructs a shared_ptr with ptr as the pointer to the managed object.
template< class Y >
explicit shared_ptr( Y* ptr );

template< class Y, class Deleter >
shared_ptr( Y* ptr, Deleter d );

template< class Y, class Deleter, class Alloc >
shared_ptr( Y* ptr, Deleter d, Alloc alloc );
```

``` cpp
// shared_ptr constructor example
#include <iostream>
#include <memory>

struct C {int* data;};

int main () {
  std::shared_ptr<int> p1;
  std::shared_ptr<int> p2 (nullptr);
  std::shared_ptr<int> p3 (new int);
  std::shared_ptr<int> p4 (new int, std::default_delete<int>());
  std::shared_ptr<int> p5 (new int, [](int* p){delete p;}, std::allocator<int>());
  std::shared_ptr<int> p6 (p5);
  std::shared_ptr<int> p7 (std::move(p6));
  std::shared_ptr<int> p8 (std::unique_ptr<int>(new int));
  std::shared_ptr<C> obj (new C);
  std::shared_ptr<int> p9 (obj, obj->data);

  std::cout << "use_count:\n";
  std::cout << "p1: " << p1.use_count() << '\n';
  std::cout << "p2: " << p2.use_count() << '\n';
  std::cout << "p3: " << p3.use_count() << '\n';
  std::cout << "p4: " << p4.use_count() << '\n';
  std::cout << "p5: " << p5.use_count() << '\n';
  std::cout << "p6: " << p6.use_count() << '\n';
  std::cout << "p7: " << p7.use_count() << '\n';
  std::cout << "p8: " << p8.use_count() << '\n';
  std::cout << "p9: " << p9.use_count() << '\n';
  return 0;
}
/*
use_count:
p1: 0
p2: 0
p3: 1
p4: 1
p5: 2
p6: 0
p7: 2
p8: 1
p9: 2
*/
```

``` cpp
#include <iostream>
#include <memory>

class Foo
{
public:
    Foo(int a) : m_a(a) { std::cout << "Foo(" << a << ")\n"; }
    ~Foo() { std::cout << "~Foo(" << m_a << ")\n"; }
    int Get() { return m_a; }
    void Set(int a) { m_a = a; }
private:
    int m_a;
};

int main()
{
    Foo *foo1 = new Foo(1);
    std::cout << "foo1: " <<  foo1 << ", " << foo1->Get() << std::endl;
    
    {
        std::shared_ptr<Foo> foo2 = std::make_shared<Foo>(2);
        std::cout << "foo2: " << foo2 << ", " << foo2->Get() << std::endl;
        
        std::cout << "before reset, foo2 use_count: " << foo2.use_count() << std::endl; 
        // foo2 is destructed and then constructs with foo1
        foo2.reset(foo1);
        std::cout << "after reset, foo2 use_count: " << foo2.use_count() << std::endl;
        
        std::cout << "after reset, foo1: " << foo1 << ", " << foo1->Get() << std::endl;
        std::cout << "after reset, foo2: " << foo2 << ", " << foo2->Get() << std::endl;
        
        foo1->Set(3);
        std::cout << "after foo1->Set(3), foo1: " << foo1 << ", " << foo1->Get() << std::endl;
        std::cout << "after foo1->Set(3), foo2: " << foo2 << ", " << foo2->Get() << std::endl;
        
        // foo2 destruct, delete foo1 buffer
    }
    std::cout << "foo1 is deleted\n";
    
    // error, foo1 is deleted
    std::cout << "after foo2 dtor, foo1: " << foo1 << ", " << foo1->Get() << std::endl;
}
/*
Foo(1)
foo1: 0x11b4d30, 1
Foo(2)
foo2: 0x11b51e0, 2
before reset, foo2 use_count: 1
~Foo(2)
after reset, foo2 use_count: 1
after reset, foo1: 0x11b4d30, 1
after reset, foo2: 0x11b4d30, 1
after foo1->Set(3), foo1: 0x11b4d30, 3
after foo1->Set(3), foo2: 0x11b4d30, 3
~Foo(3)
foo1 is deleted
after foo2 dtor, foo1: 0x11b4d30, 18567616
*/
```

``` cpp
#include <memory>
#include <iostream>
 
struct Foo {
    Foo() { std::cout << "Foo...\n"; }
    ~Foo() { std::cout << "~Foo...\n"; }
};
 
struct D { 
    void operator()(Foo* p) const {
        std::cout << "Call delete from function object...\n";
        delete p;
    }
};
 
int main()
{
    {
        std::cout << "constructor with no managed object\n";
        std::shared_ptr<Foo> sh1;
    }
 
    {
        std::cout << "constructor with object\n";
        std::shared_ptr<Foo> sh2(new Foo);
        std::shared_ptr<Foo> sh3(sh2);
        std::cout << sh2.use_count() << '\n';
        std::cout << sh3.use_count() << '\n';
    }
 
    {
        std::cout << "constructor with object and deleter\n";
        std::shared_ptr<Foo> sh4(new Foo, D());
        std::shared_ptr<Foo> sh5(new Foo, [](auto p) {
           std::cout << "Call delete from lambda...\n";
           delete p;
        });
    }
}
/*
constructor with no managed object
constructor with object
Foo...
2
2
~Foo...
constructor with object and deleter
Foo...
Foo...
Call delete from lambda...
~Foo...
Call delete from function object...
~Foo..
*/
```

``` cpp
template< class Y >
shared_ptr( const shared_ptr<Y>& r, element_type* ptr ) noexcept;
```

**The aliasing constructor:** constructs a shared_ptr which shares ownership information with the initial value of `r`, but holds an unrelated and unmanaged pointer `ptr`. If this shared_ptr is the last of the group to go out of scope, it will call the stored deleter for the object originally managed by `r`. However, calling `get()` on this shared_ptr will always return a copy of `ptr`. It is the responsibility of the programmer to make sure that this ptr remains valid as long as this shared_ptr exists, such as in the typical use cases where ptr is a member of the object managed by `r` or is an alias (e.g., downcast) of `r.get()`.

[另一个解释](https://www.cplusplus.com/reference/memory/shared_ptr/shared_ptr/)：

``` cpp
template <class U> shared_ptr (const shared_ptr<U>& x, element_type* p) noexcept;
```

The object does not own `p`, and will not manage its storage. Instead, it co-owns x's managed object and counts as one additional use of `x`. It will also delete x's pointer on release (and not `p`). It can be used to point to members of objects that are already managed. 

新构造的shared_ptr对象，假设为`y`，与构造参数shared_ptr对象`x`共享`x`所管理的指针资源的计数，当引用计数为0时，会自动释放`x`关联的指针，而非`element_type* p`。通常用法是，`y`指向的是`x`关联对象的成员`p`，`y`不负责对`p`的内存释放。

测试代码：

``` cpp
#include <iostream>
#include <memory>

class Foo
{
public:
    Foo(int a) : m_a(a) { std::cout << "Foo(" << a << ")\n"; }
    ~Foo() { std::cout << "~Foo(" << m_a << ")\n"; }
    int Get() { return m_a; }
    void Set(int a) { m_a = a; }

public:
    int m_a;
};

int main()
{
    std::shared_ptr<Foo> foo = std::make_shared<Foo>(100);
    std::cout << "foo: " << foo.use_count() << '\n';
    
    std::shared_ptr<int> m(foo, &(foo.get()->m_a) ); 
    std::cout << *m.get() << std::endl;
    auto p_m = m.get();
    *p_m = 200;
    std::cout << foo->Get() << std::endl;
    std::cout << *m.get() << std::endl;
    std::cout << "foo: " << foo.use_count() << '\n';
    foo.reset();
    std::cout << "foo: " << foo.use_count() << '\n';
    std::cout << "m: " << m.use_count() << '\n';
}
/*
Foo(100)
foo: 1
100
200
200
foo: 2
foo: 0
m: 1
~Foo(200)
*/
```

``` cpp
#include <iostream>
#include <memory>

class Bar
{
public:
    Bar() { std::cout << "Bar()\n"; }
    Bar(int *p) : m_a_ref(p) { std::cout << "Bar()\n"; }
    ~Bar() { std::cout << "~Bar()\n"; }
public:
    int* m_a_ref;
};

class Foo
{
public:
    Foo(int a) : m_a(a) { std::cout << "Foo(" << a << ")\n"; }
    ~Foo() { std::cout << "~Foo(" << m_a << ")\n"; }
    int Get() { return m_a; }
    void Set(int a) { m_a = a; }

public:
    int m_a;
};

int main()
{
    std::shared_ptr<Foo> foo = std::make_shared<Foo>(100);
    std::cout << "foo: " << foo.use_count() << '\n';
    
    std::shared_ptr<Bar> bar(foo, new Bar(&(foo.get()->m_a)) ); // memory leak !
    std::cout << "foo: " << foo.use_count() << '\n';
    foo.reset();
    std::cout << "foo: " << foo.use_count() << '\n';
    std::cout << "bar: " << bar.use_count() << '\n';
    std::cout << *bar.get()->m_a_ref << std::endl;

}
/*
Foo(100)
foo: 1
Bar()
foo: 2
foo: 0
bar: 1
100
~Foo(100)
*/
```

* https://en.cppreference.com/w/cpp/memory/shared_ptr

## std::weak_ptr

`std::weak_ptr` is a smart pointer that holds a non-owning ("weak") reference to an object that is managed by `std::shared_ptr`. It must be converted to `std::shared_ptr` in order to access the referenced object.

`std::weak_ptr` models temporary ownership: when an object needs to be accessed only if it exists, and it may be deleted at any time by someone else, `std::weak_ptr` is used to track the object, and it is converted to `std::shared_ptr` to assume temporary ownership. If the original `std::shared_ptr` is destroyed at this time, the object's lifetime is extended until the temporary `std::shared_ptr` is destroyed as well.

Another use for `std::weak_ptr` is to break reference cycles formed by objects managed by `std::shared_ptr`. If such cycle is orphaned (i,e. there are no outside shared pointers into the cycle), the shared_ptr reference counts cannot reach zero and the memory is leaked. To prevent this, one of the pointers in the cycle can be made weak.

``` cpp
#include <iostream>
#include <memory>
 
std::weak_ptr<int> gw;

void observe()
{
    std::cout << "use_count == " << gw.use_count() << ": ";
    if (auto spt = gw.lock()) { // Has to be copied into a shared_ptr before usage
	std::cout << *spt << "\n";
    }
    else {
        std::cout << "gw is expired\n";
    }
}

int main()
{
  {
    auto sp = std::make_shared<int>(42);
    gw = sp;
    observe();
  }
  observe();
}
/*
use_count == 1: 42
use_count == 0: gw is expired
*/
```

* https://en.cppreference.com/w/cpp/memory/weak_ptr

## std::unique_ptr

`std::unique_ptr` is a smart pointer that owns and manages another object through a pointer and disposes of that object when the unique_ptr goes out of scope.

The object is disposed of, using the associated deleter when either of the following happens:

* the managing unique_ptr object is destroyed
* the managing unique_ptr object is assigned another pointer via operator= or reset().

* https://en.cppreference.com/w/cpp/memory/unique_ptr

## std::enable_shared_from_this

* `std::enable_shared_from_this` allows an object `t` that is currently managed by a `std::shared_ptr` named `pt` to safely generate additional `std::shared_ptr` instances pt1, pt2, ... that all share ownership of t with `pt`.
* **Publicly inheriting** from `std::enable_shared_from_this<T>` provides the type T with a member function `shared_from_this`. If an object t of type `T` is managed by a `std::shared_ptr<T>` named `pt`, then calling `T::shared_from_this` will return a new `std::shared_ptr<T>` that shares ownership of t with `pt`.

``` cpp
#include <memory>
#include <iostream>
 
struct Good: public std::enable_shared_from_this<Good> // note: public inheritance
{
    std::shared_ptr<Good> getptr() {
        return shared_from_this();
    }
};
 
struct Bad
{
    std::shared_ptr<Bad> getptr() {
        return std::shared_ptr<Bad>(this);
    }
    ~Bad() { std::cout << "Bad::~Bad() called\n"; }
};
 
int main()
{
    // Good: the two shared_ptr's share the same object
    std::shared_ptr<Good> gp1 = std::make_shared<Good>();
    std::shared_ptr<Good> gp2 = gp1->getptr();
    std::cout << "gp2.use_count() = " << gp2.use_count() << '\n';
 
    // Bad: shared_from_this is called without having std::shared_ptr owning the caller 
    try {
        Good not_so_good;
        std::shared_ptr<Good> gp1 = not_so_good.getptr();
    } catch(std::bad_weak_ptr& e) {
        // undefined behavior (until C++17) and std::bad_weak_ptr thrown (since C++17)
        std::cout << e.what() << '\n';    
    }
 
    // Bad, each shared_ptr thinks it's the only owner of the object
    std::shared_ptr<Bad> bp1 = std::make_shared<Bad>();
    std::shared_ptr<Bad> bp2 = bp1->getptr();
    std::cout << "bp2.use_count() = " << bp2.use_count() << '\n';
    
} // UB: double-delete of Bad
/*
gp2.use_count() = 2
bad_weak_ptr
bp2.use_count() = 1
Bad::~Bad() called
Bad::~Bad() called
*** glibc detected *** ./test: double free or corruption
*/
```

https://en.cppreference.com/w/cpp/memory/enable_shared_from_this

## std::this_thread::sleep_for

``` cpp
#include <iostream>
#include <chrono>
#include <thread>
 
int main()
{
    std::cout << "Hello waiter\n" << std::flush;
    auto start = std::chrono::high_resolution_clock::now();

    //using namespace std::chrono_literals;
    //std::this_thread::sleep_for(2000ms); // 2000ms for C++14

    std::chrono::nanoseconds ns(500 * 1000 * 1000);
    std::this_thread::sleep_for(ns);

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double, std::milli> elapsed = end-start;
    std::cout << "Waited " << elapsed.count() << " ms\n";
}
```
* https://en.cppreference.com/w/cpp/thread/sleep_for
* https://en.cppreference.com/w/cpp/chrono/duration

## std::mem_fn

* Function template `std::mem_fn` generates wrapper objects for pointers to members, which can store, copy, and invoke a pointer to member. Both references and pointers (including smart pointers) to an object can be used when invoking a `std::mem_fn`.

``` cpp
#include <functional>
#include <iostream>
 
struct Foo {
    void display_greeting() {
        std::cout << "Hello, world.\n";
    }
    void display_number(int i) {
        std::cout << "number: " << i << '\n';
    }
    int data = 7;
};
 
int main() {
    Foo f;
 
    auto greet = std::mem_fn(&Foo::display_greeting);
    greet(f);
 
    auto print_num = std::mem_fn(&Foo::display_number);
    print_num(f, 42);
 
    auto access_data = std::mem_fn(&Foo::data);
    std::cout << "data: " << access_data(f) << '\n';
}
```

* https://en.cppreference.com/w/cpp/utility/functional/mem_fn

## std::uniform_int_distribution

* Produces random integer values `i`, uniformly distributed on the closed interval `[a, b]`, that is, distributed according to the discrete probability function `P(i|a,b) = 1/(b - a + 1)` 

``` cpp
#include <random>
#include <iostream>
 
int main()
{
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> distrib(1, 6);
 
    for (int n=0; n<10; ++n)
        //Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6]
        std::cout << distrib(gen) << ' ';
    std::cout << '\n';
}
/*
3 6 5 6 1 2 2 4 3 3 
*/
```
* https://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution

## std::bind

The function template `bind` generates a forwarding call wrapper for `f`. Calling this wrapper is equivalent to invoking `f` with some of its arguments bound to args.

* `f`	-	[Callable object](https://en.cppreference.com/w/cpp/named_req/Callable) (`function object`, `pointer to function`, `reference to function`, `pointer to member function`, or `pointer to data member`) that will be bound to some arguments
* `args`	-	list of arguments to bind, with the unbound arguments replaced by the placeholders `_1`, `_2`, `_3`... of namespace `std::placeholders`
* As described in `Callable`, when invoking a `pointer to non-static member function` or `pointer to non-static data member`, **the first argument has to be a reference or pointer (including, possibly, smart pointer such as std::shared_ptr and std::unique_ptr) to an object** whose member will be accessed.
* The arguments to bind are **copied or moved, and are never passed by reference unless wrapped in `std::ref` or `std::cref`**.
* Duplicate placeholders in the same bind expression (multiple `_1`'s for example) are allowed, but the results are only well defined if the corresponding argument (u1) is an `lvalue` or `non-movable rvalue`.

``` cpp
#include <random>
#include <iostream>
#include <memory>
#include <functional>
 
void f(int n1, int n2, int n3, const int& n4, int n5)
{
    std::cout << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << '\n';
}

int g(int n1)
{
    return n1;
}
 
struct Foo {
    void print_sum(int n1, int n2)
    {
        std::cout << n1+n2 << '\n';
    }
    int data = 10;
};

int main()
{
    using namespace std::placeholders;  // for _1, _2, _3...
 
    std::cout << "demonstrates argument reordering and pass-by-reference:\n";
    int n = 7;
    // (_1 and _2 are from std::placeholders, and represent future
    // arguments that will be passed to f1)
    auto f1 = std::bind(f, _2, 42, _1, std::cref(n), n);
    n = 10;
    f1(1, 2, 1001); // 1 is bound by _1, 2 is bound by _2, 1001 is unused
                    // makes a call to f(2, 42, 1, n, 7)
    
    std::cout << "achieving the same effect using a lambda:\n";
    auto lambda = [ncref=std::cref(n), n=n](auto a, auto b, auto /*unused*/) {
        f(b, 42, a, ncref, n);
    };
    lambda(1, 2, 1001); // same as a call to f1(1, 2, 1001)
    
    std::cout << "nested bind subexpressions share the placeholders:\n";
    auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);
    f2(10, 11, 12); // makes a call to f(12, g(12), 12, 4, 5);
    
    std::cout << "bind to a pointer to member function:\n";
    Foo foo;
    auto f3 = std::bind(&Foo::print_sum, &foo, 95, _1);
    f3(5);
    
    std::cout << "bind to a pointer to data member:\n";
    auto f4 = std::bind(&Foo::data, _1);
    std::cout << f4(foo) << '\n';
    
    std::cout << "use smart pointers to call members of the referenced objects:\n";
    std::cout << f4(std::make_shared<Foo>(foo)) << ' '
              << f4(std::make_unique<Foo>(foo)) << '\n';
}
/*
demonstrates argument reordering and pass-by-reference:
2 42 1 10 7
achieving the same effect using a lambda:
2 42 1 10 10
nested bind subexpressions share the placeholders:
12 12 12 4 5
bind to a pointer to member function:
100
bind to a pointer to data member:
10
use smart pointers to call members of the referenced objects:
10 10
*/
```

* https://en.cppreference.com/w/cpp/utility/functional/bind

## override specifier (覆盖)

Specifies that a virtual function overrides another virtual function.

The override keyword serves two purposes:

1. It shows the reader of the code that "this is a virtual method, that is overriding a virtual method of the base class."
2. The compiler also knows that it's an override, so it can "check" that you are not altering/adding new methods that you think are overrides.

``` cpp
class base
{
  public:
    virtual int foo(float x) = 0; 
};
class derived: public base
{
   public:
     int foo(float x) override { ... } // OK
}
class derived2: public base
{
   public:
     int foo(int x) override { ... } // ERROR
};
```

In derived2 the compiler will issue an error for "changing the type". Without override, at most the compiler would give a warning for "you are hiding virtual method by same name".

* https://en.cppreference.com/w/cpp/language/override
* https://stackoverflow.com/questions/18198314/what-is-the-override-keyword-in-c-used-for


## std::abort

Causes abnormal program termination unless `SIGABRT` is being caught by a signal handler passed to `std::signal` and the handler does not return.

``` cpp
#include <csignal>
#include <iostream>
#include <cstdlib>
 
class Tester {
public:
    Tester()  { std::cout << "Tester ctor\n"; }
    ~Tester() { std::cout << "Tester dtor\n"; }
};
 
Tester static_tester; // Destructor not called
 
void signal_handler(int signal) 
{
    if (signal == SIGABRT) {
        std::cerr << "SIGABRT received\n";
    } else {
        std::cerr << "Unexpected signal " << signal << " received\n";
    }
    std::_Exit(EXIT_FAILURE);
}
 
int main()
{
    Tester automatic_tester; // Destructor not called
 
    // Setup handler
    auto previous_handler = std::signal(SIGABRT, signal_handler);
    if (previous_handler == SIG_ERR) {
        std::cerr << "Setup failed\n";
        return EXIT_FAILURE;
    }
 
    std::abort();  // Raise SIGABRT
    std::cout << "This code is unreachable\n";
}
/*
Tester ctor
Tester ctor
SIGABRT received
*/
```

# C++14

## std::for_each

``` cpp
#include <map>
#include <algorithm>

int main()
{
    std::map<int, int> m { {1,1}, {2,2}, {3,3} };
    std::cout << m.size() << std::endl; // 3
    
    for (auto cur = m.begin(); cur != m.end();) {
        
        if (cur->first == 1 || cur->first == 3) {
            cur = m.erase(cur);
        } else {
            ++cur;
        }
    }
    std::cout << m.size() << std::endl; // 1
    std::for_each(m.begin(), m.end(), [](const auto& pair) {std::cout << pair.first << std::endl;}); // 2
}
```

* https://en.cppreference.com/w/cpp/algorithm/for_each

# C++17

## std::basic_string_view

A typical implementation holds only two members: a pointer to constant CharT and a size. Several typedefs for common character types are provided:

``` cpp
// std::basic_string_view<char> == std::string_view
template<
    class CharT,
    class Traits = std::char_traits<CharT>
> class basic_string_view;
```

It is the programmer's responsibility to ensure that std::string_view does not outlive the pointed-to character array:

``` cpp
std::string_view good{"a string literal"};
  // "Good" case: `good` points to a static array (string literals are usually
  // resided in persistent data segments).
 
std::string_view bad{"a temporary string"s}; 
  // "Bad" case: `bad` holds a dangling pointer since the std::string temporary,
  // created by std::operator""s, will be destroyed at the end of the statement.
```

``` cpp
#include <iostream>
#include <string>
#include <string_view>
#include <iomanip> // std::quoted
 
int main()
{ 
    char array[3] = {'B', 'a', 'r'};
    
    // constexpr basic_string_view( const CharT* s, size_type count )
    std::string_view array_v(array, std::size(array));
    std::cout << "array_v: " << std::quoted( array_v ) << '\n';
 
    std::string cppstr = "Foo";
    
    // constexpr basic_string_view( const CharT* s )
    std::string_view cppstr_v(cppstr); 
    std::cout << "cppstr_v: " << std::quoted( cppstr_v ) << '\n';
}
/*
array_v: "Bar"
cppstr_v: "Foo"
*/
```

* https://en.cppreference.com/w/cpp/string/basic_string_view

## maybe_unused

``` cpp
#include <cassert>
 
[[maybe_unused]] void f([[maybe_unused]] bool thing1,
                        [[maybe_unused]] bool thing2)
{
   [[maybe_unused]] bool b = thing1 && thing2;
   assert(b); // in release mode, assert is compiled out, and b is unused
              // no warning because it is declared [[maybe_unused]]
} // parameters thing1 and thing2 are not used, no warning
 
int main() {;}
```

* https://en.cppreference.com/w/cpp/language/attributes/maybe_unused


# C++20

## std::source_location

The `source_location` class represents certain information about the source code, such as file names, line numbers, and function names. Previously, functions that desire to obtain this information about the call site (for logging, testing, or debugging purposes) must use macros so that predefined macros like `__LINE__` and` __FILE__` are expanded in the context of the caller. The source_location class provides a better alternative.

gcc 11.1.0

``` cpp
#include <iostream>
#include <string_view>
#include <source_location>
 
void log(const std::string_view message,
         const std::source_location location = 
               std::source_location::current())
{
    std::cout << "file: "
              << location.file_name() << "("
              << location.line() << ":"
              << location.column() << ") `"
              << location.function_name() << "`: "
              << message << '\n';
}
 
template <typename T> void fun(T x)
{
    log(x);
}
 
int main(int, char*[])
{
    log("Hello world!");
    fun("Hello C++20!");
}
/*
file: prog.cc(24:8) `int main(int, char**)`: Hello world!
file: prog.cc(19:8) `void fun(T) [with T = const char*]`: Hello C++20!
*/
```

* https://en.cppreference.com/w/cpp/utility/source_location

## Text formatting

``` cpp
#include <format>
#include <iostream>
#include <string>
#include <string_view>
 
template <typename... Args>
std::string dyna_print(std::string_view rt_fmt_str, Args&&... args) {
    return std::vformat(rt_fmt_str, std::make_format_args(args...));
}
 
int main() {
    std::cout << std::format("Hello {}!\n", "world");
 
    std::string fmt;
    for (int i{}; i != 3; ++i) {
        fmt += "{} "; // constructs the formatting string
        std::cout << fmt << " : ";
        std::cout << dyna_print(fmt, "alpha", 'Z', 3.14, "unused");
        std::cout << '\n';
    }
}
/*
Hello world!
{}  : alpha 
{} {}  : alpha Z 
{} {} {}  : alpha Z 3.14
*/
```

* https://en.cppreference.com/w/cpp/utility/format
* https://github.com/fmtlib/fmt


# Clang-Format Style Options

https://clang.llvm.org/docs/ClangFormatStyleOptions.html

	
	