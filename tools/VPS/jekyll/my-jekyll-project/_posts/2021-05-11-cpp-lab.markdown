---
layout: post
title:  "CPP Lab"
date:   2021-05-11 08:00:00 +0800
categories: [C/C++]
---

* Do not remove this line (it will not be displayed)
{:toc}

# Prepare

* 编译器对标准的支持情况：https://en.cppreference.com/w/cpp/compiler_support
* 模版实例化工具：https://cppinsights.io/
* 编译运行工具：https://wandbox.org/

查看当前环境C++版本：

```
$ ls -l /lib64/libstdc++.so.6
lrwxrwxrwx 1 root root 19 Aug 18  2020 /lib64/libstdc++.so.6 -> libstdc++.so.6.0.25
$ rpm -qf /lib64/libstdc++.so.6
libstdc++-8.3.1-5.el8.0.2.x86_64
```

# TODO

* [What every C++ programmer should know, The hard part](http://web.archive.org/web/20131210001207/http://thomas-sanchez.net/computer-sciences/2011/08/15/what-every-c-programmer-should-know-the-hard-part/)
* [Stacktrace from exception](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2370r0.html)
* https://stackoverflow.com/questions/2354784/attribute-formatprintf-1-2-for-msvc
* https://yun.weicheng.men/Book/C%2B%2B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97.pdf

* https://en.cppreference.com/w/cpp/language/initialization

# Argument-dependent lookup

* https://en.cppreference.com/w/cpp/language/adl

# va_list

``` cpp
#include <iostream>
#include <stdarg.h>

int MyPrintf (const char *fmt, ...)
{
  va_list arg;
  int done;

  va_start (arg, fmt);
  done = vfprintf (stdout, fmt, arg);
  va_end (arg);

  return done;
}

int main()
{
    std::cout << sizeof(va_list) << std::endl; // 24
    int a = 1;
    MyPrintf("hello %d\n", a); // hello 1
}
```

# 内存管理

* [malloc_trim](https://man7.org/linux/man-pages/man3/malloc_trim.3.html) function attempts to release free memory from the heap (by calling `sbrk(2)` or `madvise(2)` with suitable arguments). This function is a GNU extension.

# 虚函数表(Virtual Tables)

> “A virtual method table (VMT),…, is a mechanism used in a programming language to support dynamic dispatch.” –[Wikipedia](https://en.wikipedia.org/wiki/Virtual_method_table)

* https://pabloariasal.github.io/2017/06/10/understanding-virtual-tables/

# const_cast/dynamic_cast/static_cast/reinterpret_cast/std::dynamic_pointer_cast

* [When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?](https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used)

## [std::dynamic_pointer_cast](http://www.cplusplus.com/reference/memory/dynamic_pointer_cast/)

Dynamic cast of `shared_ptr`. Returns a copy of `sp` of the proper type with its stored pointer casted dynamically from `U*` to `T*`.

``` cpp
template <class T, class U>
shared_ptr<T> dynamic_pointer_cast (const shared_ptr<U>& sp) noexcept;
```

``` cpp
#include <iostream>
#include <memory>

struct A {
  static const char* static_type;
  const char* dynamic_type;
  A() { dynamic_type = static_type; }
};

struct B: public A {
  static const char* static_type;
  B() { dynamic_type = static_type; }
};

const char* A::static_type = "class A";
const char* B::static_type = "class B";

int main () {
  std::shared_ptr<A> foo;
  std::shared_ptr<B> bar;

  bar = std::make_shared<B>();

  foo = std::dynamic_pointer_cast<A>(bar); // 类型转换 B -> A

  std::cout << "foo's static  type: " << foo->static_type << '\n';
  std::cout << "foo's dynamic type: " << foo->dynamic_type << '\n';
  std::cout << "bar's static  type: " << bar->static_type << '\n';
  std::cout << "bar's dynamic type: " << bar->dynamic_type << '\n';
}
/*
foo's static  type: class A
foo's dynamic type: class B
bar's static  type: class B
bar's dynamic type: class B
*/
```

## [dynamic_cast conversion](https://en.cppreference.com/w/cpp/language/dynamic_cast)

Safely converts pointers and references to classes up, down, and sideways along the inheritance hierarchy.

```
A -> V
B -> V
D -> A, B

D d;       // the most derived object
A& a = d;  // upcast, dynamic_cast may be used, but unnecessary  子类 -> 父类

D& new_d = dynamic_cast<D&>(a); // downcast 父类 -> 子类

B& new_b = dynamic_cast<B&>(a); // sidecast  父类 -> 子类（另一个）
```

Syntax:

`dynamic_cast < new-type > ( expression )`		

Notes:

* A downcast can also be performed with `static_cast`, which avoids the cost of the runtime check, but it's only safe if the program can guarantee (through some other logic) that the object pointed to by expression is definitely Derived.
* Some forms of `dynamic_cast` rely on [runtime type identification (RTTI)](https://en.wikipedia.org/wiki/Run-time_type_information), that is, information about each polymorphic class in the compiled program. Compilers typically have options to disable the inclusion of this information.

``` cpp
#include <iostream>
 
struct V {
    virtual void f() {}  // must be polymorphic to use runtime-checked dynamic_cast
};
struct A : virtual V {};
struct B : virtual V {
  B(V* v, A* a) {
    // casts during construction (see the call in the constructor of D below)
    dynamic_cast<B*>(v); // well-defined: v of type V*, V base of B, results in B*
    dynamic_cast<B*>(a); // undefined behavior: a has type A*, A not a base of B
  }
};
struct D : A, B {
    D() : B(static_cast<A*>(this), this) { }
};
 
struct Base {
    virtual ~Base() {}
};
 
struct Derived: Base {
    virtual void name() {}
};
 
int main()
{
    D d; // the most derived object
    A& a = d; // upcast, dynamic_cast may be used, but unnecessary
    [[maybe_unused]]
    D& new_d = dynamic_cast<D&>(a); // downcast
    [[maybe_unused]]
    B& new_b = dynamic_cast<B&>(a); // sidecast
 
 
    Base* b1 = new Base;
    if(Derived* d = dynamic_cast<Derived*>(b1))   // error
    {
        std::cout << "downcast from b1 to d successful\n";
        d->name(); // safe to call
    }
 
    Base* b2 = new Derived;
    if(Derived* d = dynamic_cast<Derived*>(b2))    // ok
    {
        std::cout << "downcast from b2 to d successful\n";
        d->name(); // safe to call
    }
 
    delete b1;
    delete b2;
}
/*
downcast from b2 to d successful
*/
```

``` cpp
#include <iostream>
#include <memory>

class foo
{
public:
     foo() { std::cout << "foo()\n"; }
     virtual ~foo() { std::cout << "~foo()\n"; }
     virtual void f() {
        std::cout << "foo::f()\n";
    }
};

class bar
{
public:
   bar() { std::cout << "bar()\n"; }
   virtual ~bar() { std::cout << "~bar()\n"; }
   void f()  {
        std::cout << "bar::f()\n";
   }
    
   int a;
};

class xyz : public foo, public bar
{
public:
   xyz() { std::cout << "xyz()\n"; }
   virtual ~xyz() { std::cout << "~xyz()\n"; }
   void f()  {
        std::cout << "xyz::f()\n";
    }
    
   int b;
};

int main(int argc, char**argv) 
{
    bar* obj = new xyz();
    std::cout << "bar obj:" << obj << std::endl;
    obj->f();
    
    auto p1 = dynamic_cast<xyz*>(obj);   // ok
    std::cout << "xyz obj:" << p1 << std::endl;
    p1->f();
    
    auto p2 = static_cast<xyz*>(obj);    // ok
    std::cout << "xyz obj:" << p2 << std::endl;
    p2->f();
    
    auto p3 = reinterpret_cast<xyz*>(obj);        // error
    std::cout << "xyz obj:" << p3 << std::endl;
    //p3->f(); // error
    
    delete obj;

}
/*
foo()
bar()
xyz()
bar obj:0x1757018
bar::f()
xyz obj:0x1757010
xyz::f()
xyz obj:0x1757010
xyz::f()
xyz obj:0x1757018
~xyz()
~bar()
~foo()
*/
```

``` cpp
#include <iostream>     
#include <map>
#include <memory>

class A
{
public:
    A() { std::cout << "A::A()\n"; }
    virtual ~A() { std::cout << "~A::A()\n"; }
    virtual void f() { std::cout << "A::f()\n"; }
    int a;
};

class A2
{
public:
    A2() { std::cout << "A2::A2()\n"; }
    virtual ~A2() { std::cout << "~A2::A2()\n"; }
    virtual void f() { std::cout << "A2::f()\n"; }
    int a2;
};

class B : public A, public A2
{
public:
    B() { std::cout << "B::B()\n"; }
    virtual ~B() { std::cout << "~B::B()\n"; }
    void f() override { std::cout << "B::f()\n"; }
    int b;
};

struct NoSensePlaceHolder {};
constexpr static NoSensePlaceHolder NoSenseHolder{};

class Buffer
{
public:
    explicit Buffer(NoSensePlaceHolder holder) : m_size(0), m_mem_ptr(nullptr) { std::cout << "Buffer(NoSensePlaceHolder holder)\n";  }
    virtual ~Buffer() { std::cout << "~Buffer()\n"; }
    
    int m_size;
    char* m_mem_ptr;
};
using BufferPtr = std::shared_ptr<Buffer>;


template <typename ObjType>
class ObjBuffer : public Buffer
{
public:
    ObjBuffer() : Buffer(NoSenseHolder) { 
        std::cout << "ObjBuffer()\n";
        m_mem_ptr = reinterpret_cast<char*>(new ObjType());
    }
    
    explicit ObjBuffer(const std::shared_ptr<ObjType>& ref) : Buffer(NoSenseHolder) {
        std::cout << "ObjBuffer(const std::shared_ptr<ObjType>& ref)\n";
        m_obj_ptr_ref = ref;
        m_mem_ptr = reinterpret_cast<char*>(ref.get());
    }
    
    virtual ~ObjBuffer() { std::cout << "~ObjBuffer()\n"; }
    
    ObjType* Cast() { return reinterpret_cast<ObjType*>(m_mem_ptr); }

protected:
    std::shared_ptr<ObjType> m_obj_ptr_ref;
    
};

// B -> A, A2
// ObjBuffer -> Buffer
int main()
{
    auto bPtr = std::make_shared<B>();
    std::cout << "bPtr: " << bPtr.get() << std::endl;
    bPtr->f();
    
    // 类型转换 B --> ObjBuffer<B> --> Buffer
    BufferPtr buff(new ObjBuffer<B>(bPtr));
    
    // 类型转换 Buffer --> ObjBuffer<>
    
    // dynamic_cast
    //auto objbuff = dynamic_cast<ObjBuffer<A>*>(buff.get());     // error, type Buffer != ObjBuffer<A>  
    //auto objbuff = dynamic_cast<ObjBuffer<A2>*>(buff.get());    // error, type Buffer != ObjBuffer<A2>
    //auto objbuff = dynamic_cast<ObjBuffer<B>*>(buff.get());     // ok, type Buffer = ObjBuffer<B>
    
    // static_cast
    auto objbuff = static_cast<ObjBuffer<A>*>(buff.get());     // ok
    //auto objbuff = static_cast<ObjBuffer<A2>*>(buff.get());    // ok
    //auto objbuff = static_cast<ObjBuffer<B>*>(buff.get());     // ok
    
    // reinterpret_cast
    //auto objbuff = reinterpret_cast<ObjBuffer<A>*>(buff.get());   // 不安全
    //auto objbuff = reinterpret_cast<ObjBuffer<A2>*>(buff.get());  // 不安全
    //auto objbuff = reinterpret_cast<ObjBuffer<B>*>(buff.get());   // 不安全
    
    // c convert
    //auto objbuff = (ObjBuffer<A>*)(buff.get());    // ok
    //auto objbuff = (ObjBuffer<A2>*)(buff.get());   // ok
    //auto objbuff = (ObjBuffer<B>*)(buff.get());    // ok
    
  
    if (!objbuff) {
        std::cout << "objbuff is nullptr\n";
        return 1;
    }
    
    // 类型转换 ObjBuffer<> --> B
    auto origobj = objbuff->Cast();
    std::cout << "origobj: " << origobj << std::endl;
    origobj->f();
    
}
```


# 虚继承

C++指出，当derived class对象经由一个base class指针被删除，而该base class带着一个non-virtual析构函数，其结果未定义 —— 实际执行时通常发生的是，对象的derived成分没被销毁。于是造成一个诡异的“局部销毁”对象，从而导致资源泄露。

> 观点1：任何class只要带有virtual函数，都几乎确定应该也有一个virtual析构函数。

> 观点2：如果class不含virtual函数，通常表示它并不意图被用做一个base class。当class不企图被当做base class，令其析构函数为virtual往往是一个馊主意。因为，欲实现出virtual函数，对象必须携带某些信息，主要用来在运行期决定哪一个virtual函数该被调用。这份信息通常是由一个所谓vptr(virtual table pointer)指出，vptr指向一个由函数指针构成的数组，称为vtbl(virtual table)。每一个带有virtual函数的class都有一个相应的vtbl。当对象调用某一virtual函数，实际被调用的函数取决于该对象的vptr所指的那个vtbl（编译器在其中寻找合适的函数指针）。这样，如果base class内含virtual函数，那么其对象的体积会增加，在32-bits计算机体系结构中将多占用32bits（vptr大小）；而在64-bits计算机体系结构中多占用64bits（指针大小为8字节）。

> 观点3：标准库string不含任何virtual函数，但有时程序员会错误地把它当做base class。那么，当你在程序任意某处无意间将一个pointer-to-specialstring转换为一个pointer-to-string，然后将转换所得的那个string指针delete掉，则立刻被流放到”不明确行为上”。很不幸C++目前没有提供类似Java的final classes禁止派生的机制。

> 请记住
> 1. 从里向外构造（ctor），从外向里析构（dtor）
> 2. polymorphic (带多态性质) base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。
> 3. classes的设计目的如果不是作为base classes使用，或不是为了具备多态性使用，此class就不该声明virtual析构函数。

测试代码：

继承和组合：

``` cpp
#include <iostream>

class A1
{
public:
    A1() {std::cout << "A1()\n"; m_a1 = new int(1); }
    ~A1() {std::cout << "~A1()\n"; delete m_a1;}
    
private:
    int* m_a1;
};

class A2 
{
public:
    A2() {std::cout << "A2()\n"; m_a2 = new int(1); }
    virtual ~A2() {std::cout << "~A2()\n"; delete m_a2;}  
    
private:
    int* m_a2;
};

class B : public A2
{
public:
    B() {std::cout << "B()\n"; m_a = new int(1); }
    ~B() {std::cout << "~B()\n"; delete m_a;}
    
private:
    int* m_a;
    A1 m_obj;
};

int main()
{
    A2* a = new B();
    delete a;      // 当A2的析构函数为virtual类型时, 此时delete才会调用B的析构函数
}
/*
A1()
A2()
B()
~B()
~A2()
~A1()
*/
```

``` cpp
#include <iostream>

class A1
{
public:
    A1() {std::cout << "A1()\n"; m_a1 = new int(1); }
    virtual ~A1() {std::cout << "~A1()\n"; delete m_a1; } 
    
private:
    int* m_a1; 
};

class A2 : A1
{
public:
    A2() {std::cout << "A2()\n"; m_a2 = new int(1); }
    virtual ~A2() {std::cout << "~A2()\n"; delete m_a2;}
    
private:
    int* m_a2;
};

class B : public A2
{
public:
    B() {std::cout << "B()\n"; m_a = new int(1); }
    ~B() {std::cout << "~B()\n"; delete m_a;}
    
private:
    int* m_a; 
};

int main()
{
    A2* a = new B(); // A1或A2有一个析构函数为virtual才会调用B的析构函数
    delete a;
}
/*
A1()
A2()
B()
~B()
~A2()
~A1()
*/
```

多重继承：

``` cpp
#include <iostream>

class A1
{
public:
    A1() {std::cout << "A1()\n"; m_a1 = new int(1); }
    ~A1() {std::cout << "~A1()\n"; delete m_a1;}
    
private:
    int* m_a1;
};

class A2
{
public:
    A2() {std::cout << "A2()\n"; m_a2 = new int(1); }
    virtual ~A2() {std::cout << "~A2()\n"; delete m_a2;}
    
private:
    int* m_a2;
};

class B : public A1, public A2
{
public:
    B() {std::cout << "B()\n"; m_a = new int(1); }
    ~B() {std::cout << "~B()\n"; delete m_a;}
    
private:
    int* m_a;
};

int main()
{
    A2* a = new B();
    delete a;   // A2的析构函数需为virtual
}
/*
A1()
A2()
B()
~B()
~A2()
~A1()
*/
```

# I/O

``` cpp
#include <iostream>
#include <string>
#include <vector>

template<typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec)
{
    for (auto& el : vec)
    {
        os << el << ' ';
    }
    return os;
}

int main()
{
    std::vector<std::string> vec = {
        "Hello", "from", "GCC", __VERSION__, "!" 
    };
    std::cout << vec << std::endl;
}
```

# STL

## Map

``` cpp

#include <iostream>
#include <map>

struct S
{
    S(int i, int j) : a(i), b(j) {}
    int a;
    int b;

    // ok, use operator< to sort
    bool operator<(const S& rhs) const
    {
        if (a < rhs.a)
        {
            return true;
        }
        else if (a == rhs.a)
        {
            if (b < rhs.b)
            {
                return true;
            }
            return false;
        }
        else
        {
            return false;
        }
    }
};

// ok, use operator< to sort
bool operator<(const S& lhs, const S& rhs)
{
    if (lhs.a < rhs.a)
    {
        return true;
    }
    else if (lhs.a == rhs.a)
    {
        if (lhs.b < rhs.b)
        {
            return true;
        }
        return false;
    }
    else
    {
        return false;
    }
}

// ok
struct SCompare
{
    bool operator()(const S& lhs, const S& rhs) const
    {
        if (lhs.a < rhs.a)
        {
            return true;
        }
        else if (lhs.a == rhs.a)
        {
            if (lhs.b < rhs.b)
            {
                return true;
            }
            return false;
        }
        else
        {
            return false;
        }
    }
};

// ok
namespace std
{
template<>
struct less<S>
{
    bool operator()(const S& lhs, const S& rhs) const
    {
        if (lhs.a < rhs.a)
        {
            return true;
        }
        else if (lhs.a == rhs.a)
        {
            if (lhs.b < rhs.b)
            {
                return true;
            }
            return false;
        }
        else
        {
            return false;
        }
    }
};
}

//using Map = std::map<S, std::string, SCompare>;
using Map = std::map<S, std::string>;

int main()
{
    Map m;

    auto f1 = [](bool b) { b ? std::cout << "true\n" : std::cout << "false\n"; };

    f1(m.emplace(std::make_pair(S(1, 1), "a")).second);
    f1(m.emplace(std::make_pair(S(1, 2), "b")).second);
    f1(m.emplace(std::make_pair(S(2, 1), "c")).second);

    auto f2 = [&m]()
    {
        for (auto& n : m)
        {
            std::cout << n.second << " ";
        }
    };
    f2();

    return 0;
}
/*
true
true
true
a b c
*/
```


# Alignment and Bit Fields

* [测试代码](https://github.com/gerryyang/mac-utils/tree/master/programing/cpp/alignment)
* [pragma pack effect](https://stackoverflow.com/questions/3318410/pragma-pack-effect)
* [C - Bit Fields](https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm)


# offsetof

``` cpp
#include <iostream>
#include <cstddef>

struct S {
    char   m0;
    double m1;
    short  m2;
    char   m3;
//  private: int z; // warning: 'S' is a non-standard-layout type
};
int main()
{
    std::cout
        << "offset of char   m0 = " << offsetof(S, m0) << '\n'
        << "offset of double m1 = " << offsetof(S, m1) << '\n'
        << "offset of short  m2 = " << offsetof(S, m2) << '\n'
        << "offset of char   m3 = " << offsetof(S, m3) << '\n';
}
/*
offset of char   m0 = 0
offset of double m1 = 8
offset of short  m2 = 16
offset of char   m3 = 18
*/
```

https://en.cppreference.com/w/cpp/types/offsetof

# Template

## SFINAE

``` cpp
#include <iostream>

// has_member_gc用来判断一个类T是否定义了成员函数void __gc()
template<class T>
struct has_member_gc {
  // 声明辅助模板类sfinae，它接受两个模板参数：U以及U的成员函数指针常量（签名为void()）
  template<class U, void (U::*)()>
  struct sfinae;

  // 声明辅助模板函数test，它有一个模板参数U，它有一个函数参数叫unused，unused的类型是sfinae<U, &U::__gc>*，返回类型char
  template<class U>
  static char test(sfinae<U, &U::__gc>* unused);

  // 声明辅助模板函数test的一个重载版本，它有一个模板参数，函数参数是可变参数，返回类型int
  template<class>
  static int test(...);

  // 核心的判断，考虑函数的调用：test<T>(nullptr)
  // test函数有两个重载，根据重载规则，可变参数的重载优先级是最低的，所以会优先考虑第一个重载版本
  // 编译器会先试着实例化sfinae<T, &T::__gc>，这里分两种情况考虑：
  // 1、如果T定义了成员函数void __gc()
  //   则sfinae<T, &T::__gc>是一个合法的类型，最终会调用test的第一个版本，所以test的返回类型是char
  //   这个时候，sizeof(返回类型) == sizeof(char)，value的值为true
  // 2、否则
  //   sfinae<T, &T::__gc>不是一个合法的类型，根据SFINAE规则，编译器不会报错，继续去找下一个重载版本
  //   此时会调用到test(...)，返回类型是int
  //   这个时候，sizeof(返回类型) != sizeof(char)，value的值为false
  static constexpr bool value = sizeof(test<T>(nullptr)) == sizeof(char);
};

struct foo {
  void __gc() {}
};

int main()
{
	std::cout << has_member_gc<foo>::value << " ";
	std::cout << has_member_gc<int>::value;
}
```

## std::conditional (C++11)

``` cpp
#include <iostream>
#include <type_traits>
#include <typeinfo>
 
int main() 
{
    typedef std::conditional<true, int, double>::type Type1;
    typedef std::conditional<false, int, double>::type Type2;
    typedef std::conditional<sizeof(int) >= sizeof(double), int, double>::type Type3;
 
    std::cout << typeid(Type1).name() << '\n';
    std::cout << typeid(Type2).name() << '\n';
    std::cout << typeid(Type3).name() << '\n';
}
/*
i
d
d
*/
```

https://en.cppreference.com/w/cpp/types/conditional

# C++11

## std::thread

``` cpp
#include <iostream>       // std::cout
#include <thread>         // std::thread

void foo() 
{
  std::cout << "foo()\n";
}

void bar(int x)
{
  std::cout << "bar(" << x << ")\n";
}

int main() 
{
  std::thread first (foo);      // spawn new thread that calls foo()
  std::thread second (bar, 0);  // spawn new thread that calls bar(0)

  std::cout << "main, foo and bar now execute concurrently...\n";

  // synchronize threads:
  first.join();                // pauses until first finishes
  second.join();               // pauses until second finishes

  std::cout << "foo and bar completed.\n";

  return 0;
}
/*
main, foo and bar now execute concurrently...
foo()
bar(0)
foo and bar completed.
*/
```

* https://www.cplusplus.com/reference/thread/thread/

## std::vector<T,Allocator>::shrink_to_fit

Requests the removal of unused capacity. It is a non-binding request to reduce `capacity()` to `size()`. It depends on the implementation whether the request is fulfilled. If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated.

``` cpp
#include <iostream>
#include <vector>
 
int main()
{
    std::vector<int> v;
    std::cout << "Default-constructed capacity is " << v.capacity() << '\n';
    v.resize(100);
    std::cout << "Capacity of a 100-element vector is " << v.capacity() << '\n';
    v.resize(50);
    std::cout << "Capacity after resize(50) is " << v.capacity() << '\n';
    v.shrink_to_fit();
    std::cout << "Capacity after shrink_to_fit() is " << v.capacity() << '\n';
    v.clear(); // Erases all elements from the container. After this call, size() returns zero. But capacity() is not !
    std::cout << "Capacity after clear() is " << v.capacity() << '\n';
    v.shrink_to_fit();
    std::cout << "Capacity after shrink_to_fit() is " << v.capacity() << '\n';
    for (int i = 1000; i < 1300; ++i)
        v.push_back(i);
    std::cout << "Capacity after adding 300 elements is " << v.capacity() << '\n';
    v.shrink_to_fit();
    std::cout << "Capacity after shrink_to_fit() is " << v.capacity() << '\n';
}
/*
Default-constructed capacity is 0
Capacity of a 100-element vector is 100
Capacity after resize(50) is 100
Capacity after shrink_to_fit() is 50
Capacity after clear() is 50
Capacity after shrink_to_fit() is 0
Capacity after adding 300 elements is 512
Capacity after shrink_to_fit() is 300
*/
```

* https://en.cppreference.com/w/cpp/container/vector/shrink_to_fit
## std::map<Key,T,Compare,Allocator>::emplace

``` cpp
template< class... Args >
std::pair<iterator,bool> emplace( Args&&... args );
```

Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.

``` cpp
#include <iostream>
#include <utility>
#include <string>
#include <map>
 
int main()
{
    std::map<std::string, std::string> m;
 
    // uses pair's move constructor
    m.emplace(std::make_pair(std::string("a"), std::string("a")));
 
    // uses pair's converting move constructor
    m.emplace(std::make_pair("b", "abcd"));
 
    // uses pair's template constructor
    m.emplace("d", "ddd");
 
    // uses pair's piecewise constructor
    m.emplace(std::piecewise_construct,
              std::forward_as_tuple("c"),
              std::forward_as_tuple(10, 'c'));
    // as of C++17, m.try_emplace("c", 10, 'c'); can be used
 
    for (const auto &p : m) {
        std::cout << p.first << " => " << p.second << '\n';
    }
}
/*
a => a
b => abcd
c => cccccccccc
d => ddd
*/
```


## std::shared_ptr

`std::shared_ptr` is a smart pointer that retains shared ownership of an object through a pointer. Several shared_ptr objects may own the same object. **The object is destroyed and its memory deallocated when either of the following happens**:

* the last remaining shared_ptr owning the object is destroyed;
* the last remaining shared_ptr owning the object is assigned another pointer via `operator=` or `reset()`.

The object is destroyed using `delete-expression` or a `custom deleter` that is supplied to shared_ptr during construction.

``` cpp
// Constructs a shared_ptr with ptr as the pointer to the managed object.
template< class Y >
explicit shared_ptr( Y* ptr );

template< class Y, class Deleter >
shared_ptr( Y* ptr, Deleter d );

template< class Y, class Deleter, class Alloc >
shared_ptr( Y* ptr, Deleter d, Alloc alloc );
```

``` cpp
// shared_ptr constructor example
#include <iostream>
#include <memory>

struct C {int* data;};

int main () {
  std::shared_ptr<int> p1;
  std::shared_ptr<int> p2 (nullptr);
  std::shared_ptr<int> p3 (new int);
  std::shared_ptr<int> p4 (new int, std::default_delete<int>());
  std::shared_ptr<int> p5 (new int, [](int* p){delete p;}, std::allocator<int>());
  std::shared_ptr<int> p6 (p5);
  std::shared_ptr<int> p7 (std::move(p6));
  std::shared_ptr<int> p8 (std::unique_ptr<int>(new int));
  std::shared_ptr<C> obj (new C);
  std::shared_ptr<int> p9 (obj, obj->data);

  std::cout << "use_count:\n";
  std::cout << "p1: " << p1.use_count() << '\n';
  std::cout << "p2: " << p2.use_count() << '\n';
  std::cout << "p3: " << p3.use_count() << '\n';
  std::cout << "p4: " << p4.use_count() << '\n';
  std::cout << "p5: " << p5.use_count() << '\n';
  std::cout << "p6: " << p6.use_count() << '\n';
  std::cout << "p7: " << p7.use_count() << '\n';
  std::cout << "p8: " << p8.use_count() << '\n';
  std::cout << "p9: " << p9.use_count() << '\n';
  return 0;
}
/*
use_count:
p1: 0
p2: 0
p3: 1
p4: 1
p5: 2
p6: 0
p7: 2
p8: 1
p9: 2
*/
```

``` cpp
#include <iostream>
#include <memory>

class Foo
{
public:
    Foo(int a) : m_a(a) { std::cout << "Foo(" << a << ")\n"; }
    ~Foo() { std::cout << "~Foo(" << m_a << ")\n"; }
    int Get() { return m_a; }
    void Set(int a) { m_a = a; }
private:
    int m_a;
};

int main()
{
    Foo *foo1 = new Foo(1);
    std::cout << "foo1: " <<  foo1 << ", " << foo1->Get() << std::endl;
    
    {
        std::shared_ptr<Foo> foo2 = std::make_shared<Foo>(2);
        std::cout << "foo2: " << foo2 << ", " << foo2->Get() << std::endl;
        
        std::cout << "before reset, foo2 use_count: " << foo2.use_count() << std::endl; 
        // foo2 is destructed and then constructs with foo1
        foo2.reset(foo1);
        std::cout << "after reset, foo2 use_count: " << foo2.use_count() << std::endl;
        
        std::cout << "after reset, foo1: " << foo1 << ", " << foo1->Get() << std::endl;
        std::cout << "after reset, foo2: " << foo2 << ", " << foo2->Get() << std::endl;
        
        foo1->Set(3);
        std::cout << "after foo1->Set(3), foo1: " << foo1 << ", " << foo1->Get() << std::endl;
        std::cout << "after foo1->Set(3), foo2: " << foo2 << ", " << foo2->Get() << std::endl;
        
        // foo2 destruct, delete foo1 buffer
    }
    std::cout << "foo1 is deleted\n";
    
    // error, foo1 is deleted
    std::cout << "after foo2 dtor, foo1: " << foo1 << ", " << foo1->Get() << std::endl;
}
/*
Foo(1)
foo1: 0x11b4d30, 1
Foo(2)
foo2: 0x11b51e0, 2
before reset, foo2 use_count: 1
~Foo(2)
after reset, foo2 use_count: 1
after reset, foo1: 0x11b4d30, 1
after reset, foo2: 0x11b4d30, 1
after foo1->Set(3), foo1: 0x11b4d30, 3
after foo1->Set(3), foo2: 0x11b4d30, 3
~Foo(3)
foo1 is deleted
after foo2 dtor, foo1: 0x11b4d30, 18567616
*/
```

``` cpp
#include <memory>
#include <iostream>
 
struct Foo {
    Foo() { std::cout << "Foo...\n"; }
    ~Foo() { std::cout << "~Foo...\n"; }
};
 
struct D { 
    void operator()(Foo* p) const {
        std::cout << "Call delete from function object...\n";
        delete p;
    }
};
 
int main()
{
    {
        std::cout << "constructor with no managed object\n";
        std::shared_ptr<Foo> sh1;
    }
 
    {
        std::cout << "constructor with object\n";
        std::shared_ptr<Foo> sh2(new Foo);
        std::shared_ptr<Foo> sh3(sh2);
        std::cout << sh2.use_count() << '\n';
        std::cout << sh3.use_count() << '\n';
    }
 
    {
        std::cout << "constructor with object and deleter\n";
        std::shared_ptr<Foo> sh4(new Foo, D());
        std::shared_ptr<Foo> sh5(new Foo, [](auto p) {
           std::cout << "Call delete from lambda...\n";
           delete p;
        });
    }
}
/*
constructor with no managed object
constructor with object
Foo...
2
2
~Foo...
constructor with object and deleter
Foo...
Foo...
Call delete from lambda...
~Foo...
Call delete from function object...
~Foo..
*/
```

``` cpp
template< class Y >
shared_ptr( const shared_ptr<Y>& r, element_type* ptr ) noexcept;
```

**The aliasing constructor:** constructs a shared_ptr which shares ownership information with the initial value of `r`, but holds an unrelated and unmanaged pointer `ptr`. If this shared_ptr is the last of the group to go out of scope, it will call the stored deleter for the object originally managed by `r`. However, calling `get()` on this shared_ptr will always return a copy of `ptr`. It is the responsibility of the programmer to make sure that this ptr remains valid as long as this shared_ptr exists, such as in the typical use cases where ptr is a member of the object managed by `r` or is an alias (e.g., downcast) of `r.get()`.

[另一个解释](https://www.cplusplus.com/reference/memory/shared_ptr/shared_ptr/)：

``` cpp
template <class U> shared_ptr (const shared_ptr<U>& x, element_type* p) noexcept;
```

The object does not own `p`, and will not manage its storage. Instead, it co-owns x's managed object and counts as one additional use of `x`. It will also delete x's pointer on release (and not `p`). It can be used to point to members of objects that are already managed. 

新构造的shared_ptr对象，假设为`y`，与构造参数shared_ptr对象`x`共享`x`所管理的指针资源的计数，当引用计数为0时，会自动释放`x`关联的指针，而非`element_type* p`。通常用法是，`y`指向的是`x`关联对象的成员`p`，`y`不负责对`p`的内存释放。

测试代码：

``` cpp
#include <iostream>
#include <memory>

class Foo
{
public:
    Foo(int a) : m_a(a) { std::cout << "Foo(" << a << ")\n"; }
    ~Foo() { std::cout << "~Foo(" << m_a << ")\n"; }
    int Get() { return m_a; }
    void Set(int a) { m_a = a; }

public:
    int m_a;
};

int main()
{
    std::shared_ptr<Foo> foo = std::make_shared<Foo>(100);
    std::cout << "foo: " << foo.use_count() << '\n';
    
    std::shared_ptr<int> m(foo, &(foo.get()->m_a) ); 
    std::cout << *m.get() << std::endl;
    auto p_m = m.get();
    *p_m = 200;
    std::cout << foo->Get() << std::endl;
    std::cout << *m.get() << std::endl;
    std::cout << "foo: " << foo.use_count() << '\n';
    foo.reset();
    std::cout << "foo: " << foo.use_count() << '\n';
    std::cout << "m: " << m.use_count() << '\n';
}
/*
Foo(100)
foo: 1
100
200
200
foo: 2
foo: 0
m: 1
~Foo(200)
*/
```

``` cpp
#include <iostream>
#include <memory>

class Bar
{
public:
    Bar() { std::cout << "Bar()\n"; }
    Bar(int *p) : m_a_ref(p) { std::cout << "Bar()\n"; }
    ~Bar() { std::cout << "~Bar()\n"; }
public:
    int* m_a_ref;
};

class Foo
{
public:
    Foo(int a) : m_a(a) { std::cout << "Foo(" << a << ")\n"; }
    ~Foo() { std::cout << "~Foo(" << m_a << ")\n"; }
    int Get() { return m_a; }
    void Set(int a) { m_a = a; }

public:
    int m_a;
};

int main()
{
    std::shared_ptr<Foo> foo = std::make_shared<Foo>(100);
    std::cout << "foo: " << foo.use_count() << '\n';
    
    std::shared_ptr<Bar> bar(foo, new Bar(&(foo.get()->m_a)) ); // memory leak !
    std::cout << "foo: " << foo.use_count() << '\n';
    foo.reset();
    std::cout << "foo: " << foo.use_count() << '\n';
    std::cout << "bar: " << bar.use_count() << '\n';
    std::cout << *bar.get()->m_a_ref << std::endl;

}
/*
Foo(100)
foo: 1
Bar()
foo: 2
foo: 0
bar: 1
100
~Foo(100)
*/
```

* https://en.cppreference.com/w/cpp/memory/shared_ptr

## std::weak_ptr

`std::weak_ptr` is a smart pointer that holds a non-owning ("weak") reference to an object that is managed by `std::shared_ptr`. It must be converted to `std::shared_ptr` in order to access the referenced object.

`std::weak_ptr` models temporary ownership: when an object needs to be accessed only if it exists, and it may be deleted at any time by someone else, `std::weak_ptr` is used to track the object, and it is converted to `std::shared_ptr` to assume temporary ownership. If the original `std::shared_ptr` is destroyed at this time, the object's lifetime is extended until the temporary `std::shared_ptr` is destroyed as well.

Another use for `std::weak_ptr` is to break reference cycles formed by objects managed by `std::shared_ptr`. If such cycle is orphaned (i,e. there are no outside shared pointers into the cycle), the shared_ptr reference counts cannot reach zero and the memory is leaked. To prevent this, one of the pointers in the cycle can be made weak.

``` cpp
#include <iostream>
#include <memory>
 
std::weak_ptr<int> gw;

void observe()
{
    std::cout << "use_count == " << gw.use_count() << ": ";
    if (auto spt = gw.lock()) { // Has to be copied into a shared_ptr before usage
	std::cout << *spt << "\n";
    }
    else {
        std::cout << "gw is expired\n";
    }
}

int main()
{
  {
    auto sp = std::make_shared<int>(42);
    gw = sp;
    observe();
  }
  observe();
}
/*
use_count == 1: 42
use_count == 0: gw is expired
*/
```

* https://en.cppreference.com/w/cpp/memory/weak_ptr

## std::unique_ptr

`std::unique_ptr` is a smart pointer that owns and manages another object through a pointer and disposes of that object when the unique_ptr goes out of scope.

The object is disposed of, using the associated deleter when either of the following happens:

* the managing unique_ptr object is destroyed
* the managing unique_ptr object is assigned another pointer via operator= or reset().

* https://en.cppreference.com/w/cpp/memory/unique_ptr

## std::enable_shared_from_this

* `std::enable_shared_from_this` allows an object `t` that is currently managed by a `std::shared_ptr` named `pt` to safely generate additional `std::shared_ptr` instances pt1, pt2, ... that all share ownership of t with `pt`.
* **Publicly inheriting** from `std::enable_shared_from_this<T>` provides the type T with a member function `shared_from_this`. If an object t of type `T` is managed by a `std::shared_ptr<T>` named `pt`, then calling `T::shared_from_this` will return a new `std::shared_ptr<T>` that shares ownership of t with `pt`.

``` cpp
#include <memory>
#include <iostream>
 
struct Good: public std::enable_shared_from_this<Good> // note: public inheritance
{
    std::shared_ptr<Good> getptr() {
        return shared_from_this();
    }
};
 
struct Bad
{
    std::shared_ptr<Bad> getptr() {
        return std::shared_ptr<Bad>(this);
    }
    ~Bad() { std::cout << "Bad::~Bad() called\n"; }
};
 
int main()
{
    // Good: the two shared_ptr's share the same object
    std::shared_ptr<Good> gp1 = std::make_shared<Good>();
    std::shared_ptr<Good> gp2 = gp1->getptr();
    std::cout << "gp2.use_count() = " << gp2.use_count() << '\n';
 
    // Bad: shared_from_this is called without having std::shared_ptr owning the caller 
    try {
        Good not_so_good;
        std::shared_ptr<Good> gp1 = not_so_good.getptr();
    } catch(std::bad_weak_ptr& e) {
        // undefined behavior (until C++17) and std::bad_weak_ptr thrown (since C++17)
        std::cout << e.what() << '\n';    
    }
 
    // Bad, each shared_ptr thinks it's the only owner of the object
    std::shared_ptr<Bad> bp1 = std::make_shared<Bad>();
    std::shared_ptr<Bad> bp2 = bp1->getptr();
    std::cout << "bp2.use_count() = " << bp2.use_count() << '\n';
    
} // UB: double-delete of Bad
/*
gp2.use_count() = 2
bad_weak_ptr
bp2.use_count() = 1
Bad::~Bad() called
Bad::~Bad() called
*** glibc detected *** ./test: double free or corruption
*/
```

https://en.cppreference.com/w/cpp/memory/enable_shared_from_this

## std::this_thread::sleep_for

``` cpp
#include <iostream>
#include <chrono>
#include <thread>
 
int main()
{
    std::cout << "Hello waiter\n" << std::flush;
    auto start = std::chrono::high_resolution_clock::now();

    //using namespace std::chrono_literals;
    //std::this_thread::sleep_for(2000ms); // 2000ms for C++14

    std::chrono::nanoseconds ns(500 * 1000 * 1000);
    std::this_thread::sleep_for(ns);

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double, std::milli> elapsed = end-start;
    std::cout << "Waited " << elapsed.count() << " ms\n";
}
```
* https://en.cppreference.com/w/cpp/thread/sleep_for
* https://en.cppreference.com/w/cpp/chrono/duration

## std::mem_fn

* Function template `std::mem_fn` generates wrapper objects for pointers to members, which can store, copy, and invoke a pointer to member. Both references and pointers (including smart pointers) to an object can be used when invoking a `std::mem_fn`.

``` cpp
#include <functional>
#include <iostream>
 
struct Foo {
    void display_greeting() {
        std::cout << "Hello, world.\n";
    }
    void display_number(int i) {
        std::cout << "number: " << i << '\n';
    }
    int data = 7;
};
 
int main() {
    Foo f;
 
    auto greet = std::mem_fn(&Foo::display_greeting);
    greet(f);
 
    auto print_num = std::mem_fn(&Foo::display_number);
    print_num(f, 42);
 
    auto access_data = std::mem_fn(&Foo::data);
    std::cout << "data: " << access_data(f) << '\n';
}
```

* https://en.cppreference.com/w/cpp/utility/functional/mem_fn

## std::uniform_int_distribution

* Produces random integer values `i`, uniformly distributed on the closed interval `[a, b]`, that is, distributed according to the discrete probability function `P(i|a,b) = 1/(b - a + 1)` 

``` cpp
#include <random>
#include <iostream>
 
int main()
{
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> distrib(1, 6);
 
    for (int n=0; n<10; ++n)
        //Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6]
        std::cout << distrib(gen) << ' ';
    std::cout << '\n';
}
/*
3 6 5 6 1 2 2 4 3 3 
*/
```
* https://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution

## std::bind

The function template `bind` generates a forwarding call wrapper for `f`. Calling this wrapper is equivalent to invoking `f` with some of its arguments bound to args.

* `f`	-	[Callable object](https://en.cppreference.com/w/cpp/named_req/Callable) (`function object`, `pointer to function`, `reference to function`, `pointer to member function`, or `pointer to data member`) that will be bound to some arguments
* `args`	-	list of arguments to bind, with the unbound arguments replaced by the placeholders `_1`, `_2`, `_3`... of namespace `std::placeholders`
* As described in `Callable`, when invoking a `pointer to non-static member function` or `pointer to non-static data member`, **the first argument has to be a reference or pointer (including, possibly, smart pointer such as std::shared_ptr and std::unique_ptr) to an object** whose member will be accessed.
* The arguments to bind are **copied or moved, and are never passed by reference unless wrapped in `std::ref` or `std::cref`**.
* Duplicate placeholders in the same bind expression (multiple `_1`'s for example) are allowed, but the results are only well defined if the corresponding argument (u1) is an `lvalue` or `non-movable rvalue`.

``` cpp
#include <random>
#include <iostream>
#include <memory>
#include <functional>
 
void f(int n1, int n2, int n3, const int& n4, int n5)
{
    std::cout << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << '\n';
}

int g(int n1)
{
    return n1;
}
 
struct Foo {
    void print_sum(int n1, int n2)
    {
        std::cout << n1+n2 << '\n';
    }
    int data = 10;
};

int main()
{
    using namespace std::placeholders;  // for _1, _2, _3...
 
    std::cout << "demonstrates argument reordering and pass-by-reference:\n";
    int n = 7;
    // (_1 and _2 are from std::placeholders, and represent future
    // arguments that will be passed to f1)
    auto f1 = std::bind(f, _2, 42, _1, std::cref(n), n);
    n = 10;
    f1(1, 2, 1001); // 1 is bound by _1, 2 is bound by _2, 1001 is unused
                    // makes a call to f(2, 42, 1, n, 7)
    
    std::cout << "achieving the same effect using a lambda:\n";
    auto lambda = [ncref=std::cref(n), n=n](auto a, auto b, auto /*unused*/) {
        f(b, 42, a, ncref, n);
    };
    lambda(1, 2, 1001); // same as a call to f1(1, 2, 1001)
    
    std::cout << "nested bind subexpressions share the placeholders:\n";
    auto f2 = std::bind(f, _3, std::bind(g, _3), _3, 4, 5);
    f2(10, 11, 12); // makes a call to f(12, g(12), 12, 4, 5);
    
    std::cout << "bind to a pointer to member function:\n";
    Foo foo;
    auto f3 = std::bind(&Foo::print_sum, &foo, 95, _1);
    f3(5);
    
    std::cout << "bind to a pointer to data member:\n";
    auto f4 = std::bind(&Foo::data, _1);
    std::cout << f4(foo) << '\n';
    
    std::cout << "use smart pointers to call members of the referenced objects:\n";
    std::cout << f4(std::make_shared<Foo>(foo)) << ' '
              << f4(std::make_unique<Foo>(foo)) << '\n';
}
/*
demonstrates argument reordering and pass-by-reference:
2 42 1 10 7
achieving the same effect using a lambda:
2 42 1 10 10
nested bind subexpressions share the placeholders:
12 12 12 4 5
bind to a pointer to member function:
100
bind to a pointer to data member:
10
use smart pointers to call members of the referenced objects:
10 10
*/
```

* https://en.cppreference.com/w/cpp/utility/functional/bind

## override specifier (覆盖)

Specifies that a virtual function overrides another virtual function.

The override keyword serves two purposes:

1. It shows the reader of the code that "this is a virtual method, that is overriding a virtual method of the base class."
2. The compiler also knows that it's an override, so it can "check" that you are not altering/adding new methods that you think are overrides.

``` cpp
class base
{
  public:
    virtual int foo(float x) = 0; 
};
class derived: public base
{
   public:
     int foo(float x) override { ... } // OK
}
class derived2: public base
{
   public:
     int foo(int x) override { ... } // ERROR
};
```

In derived2 the compiler will issue an error for "changing the type". Without override, at most the compiler would give a warning for "you are hiding virtual method by same name".

* https://en.cppreference.com/w/cpp/language/override
* https://stackoverflow.com/questions/18198314/what-is-the-override-keyword-in-c-used-for

## Variadic templates


* The **ellipsis** (`...`) operator has **two roles**. 
    + When it occurs to the **left** of the name of a parameter, it declares a **parameter pack**. Using the parameter pack, the user can bind **zero or more arguments** to the variadic template parameters. Parameter packs can also be used for non-type parameters. 
    + By contrast, when the ellipsis operator occurs to the **right** of a template or function call argument, **it unpacks the parameter packs into separate arguments**, like the `args...` in the body of `printf` below. 
* In practice, the use of an **ellipsis** operator in the code causes the whole expression that precedes the ellipsis to be repeated for every subsequent argument unpacked from the argument pack, with the expressions separated by commas.
* The use of **variadic templates** is often **recursive**. The variadic parameters themselves are not readily available to the implementation of a function or class. Therefore, the typical mechanism for defining something like a C++11 variadic `printf` replacement would be as follows:

``` cpp
#include <iostream>
#include <vector>
#include <type_traits>

void func_impl(std::vector<std::string> &str_vec)
{
    for (auto& item: str_vec) {
        std::cout << item << " ";
    }
    std::cout << "\nTODO";
}

static void pack_helper(std::vector<std::string> &str_vec)
{
}

template<typename... Args>
void pack_helper(std::vector<std::string> &str_vec, const std::string& str, const Args&... args)
{
    str_vec.push_back(str);
    pack_helper(str_vec, args ...);
}

// recursive
template<typename... Args>
void func(const std::string& str, const Args& ... args)
{
    std::vector<std::string> str_vec;
    pack_helper(str_vec, str, args...);
    func_impl(str_vec);
}

int main()
{
    func("1", "2", "a");
}
```

* https://en.wikipedia.org/wiki/Variadic_template
* https://www.ibm.com/docs/en/zos/2.4.0?topic=only-variadic-templates-c11

## [std::is_same](https://en.cppreference.com/w/cpp/types/is_same)

``` cpp
#include <type_traits>

template< class T, class U >
struct is_same;
```

* If `T` and `U` name the same type (taking into account `const`/`volatile` qualifications), provides the member constant value equal to `true`. Otherwise value is `false`.

``` cpp
#include <iostream>
#include <type_traits>

int main()
{
     // usually true if int is 32 bit
    std::cout << std::is_same<int, std::int32_t>::value << ' ';
    // possibly true if ILP64 data model is used
    std::cout << std::is_same<int, std::int64_t>::value;
}
/*
1 0
*/
```

`is_same`的实现方式：

``` cpp
#include <iostream>

// 定义is_same模板类，它接受两个模板参数T和U，它在类内定义了一个叫value的bool静态常量字段，值总是false
template<class T, class U>
struct is_same {
  static constexpr bool value = false;
};
// 对is_same偏特化，当T和U这两个类型一样时，它在类内定义了一个叫value的bool静态常量字段，值总是true
template<class T>
struct is_same<T, T> {
  static constexpr bool value = true;
};

int main()
{
  
  // 定义一个类型别名，将is_same<int, int>绑定到Result1
  // 从模板元编程的角度来看，这里可以看作是调用了元函数is_same，输入类型int和类型int，输出类型is_same<int, int>，赋值给Result1
  using Result1 = is_same<int, int>;

  // Result1就是类型is_same<int, int>，它有一个叫value的bool静态常量字段
  // 由于is_same<int, int>的两个模板参数都是int，所以这里是偏特化后的版本，value的值是true
  std::cout << Result1::value << " ";

  // 调用元函数is_same，输入类型int和类型float，输出类型is_same<int, float>，赋值给Result2
  using Result2 = is_same<int, float>;

  // 由于is_same<int, float>的两个模板参数不一样，所以这里没有偏特化，value的值是false
  std::cout << Result2::value << " ";

}
```


## [std::remove_cv/std::remove_const/std::remove_volatile](https://en.cppreference.com/w/cpp/types/remove_cv)

* removes the topmost `const`, or the topmost `volatile`, or both, if present.

``` cpp
#include <iostream>
#include <type_traits>
 
int main() {
    typedef std::remove_cv<const int>::type type1;
    typedef std::remove_cv<volatile int>::type type2;
    typedef std::remove_cv<const volatile int>::type type3;
    typedef std::remove_cv<const volatile int*>::type type4;
    typedef std::remove_cv<int * const volatile>::type type5;
 
    std::cout << "test1 " << (std::is_same<int, type1>::value
        ? "passed" : "failed") << '\n';
    std::cout << "test2 " << (std::is_same<int, type2>::value
        ? "passed" : "failed") << '\n';
    std::cout << "test3 " << (std::is_same<int, type3>::value
        ? "passed" : "failed") << '\n';
    std::cout << "test4 " << (std::is_same<const volatile int*, type4>::value
        ? "passed" : "failed") << '\n';
    std::cout << "test5 " << (std::is_same<int*, type5>::value
        ? "passed" : "failed") << '\n';
}
/*
test1 passed
test2 passed
test3 passed
test4 passed
test5 passed
*/
```

## [std::is_pointer](https://en.cppreference.com/w/cpp/types/is_pointer)

* Checks whether `T` is a **pointer to object** or **a pointer to function** (**but not a pointer to member/member function**). Provides the member constant value which is equal to `true`, if T is a object/function pointer type. Otherwise, value is equal to `false`.

``` cpp
#include <iostream>
#include <type_traits>
 
class A {};
 
int main() 
{
    std::cout << std::boolalpha;
    std::cout << std::is_pointer<A>::value << '\n';
    std::cout << std::is_pointer<A *>::value << '\n';
    std::cout << std::is_pointer<A &>::value << '\n';
    std::cout << std::is_pointer<int>::value << '\n';
    std::cout << std::is_pointer<int *>::value << '\n';
    std::cout << std::is_pointer<int **>::value << '\n';
    std::cout << std::is_pointer<int[10]>::value << '\n';
    std::cout << std::is_pointer<std::nullptr_t>::value << '\n';
}
/*
false
true
false
false
true
true
false
false
*/
```

## std::decay

Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type T, removes cv-qualifiers, and defines the resulting type as the member typedef type.

``` cpp
#include <iostream>
#include <type_traits>
 
template <typename T, typename U>
struct decay_equiv : 
    std::is_same<typename std::decay<T>::type, U>::type 
{};
 
int main()
{
    std::cout << std::boolalpha
              << decay_equiv<int, int>::value << '\n'
              << decay_equiv<int&, int>::value << '\n'
              << decay_equiv<int&&, int>::value << '\n'
              << decay_equiv<const int&, int>::value << '\n'
              << decay_equiv<int[2], int*>::value << '\n'
              << decay_equiv<int(int), int(*)(int)>::value << '\n';
}
```

* https://stackoverflow.com/questions/25732386/what-is-stddecay-and-when-it-should-be-used

## std::abort

Causes abnormal program termination unless `SIGABRT` is being caught by a signal handler passed to `std::signal` and the handler does not return.

``` cpp
#include <csignal>
#include <iostream>
#include <cstdlib>
 
class Tester {
public:
    Tester()  { std::cout << "Tester ctor\n"; }
    ~Tester() { std::cout << "Tester dtor\n"; }
};
 
Tester static_tester; // Destructor not called
 
void signal_handler(int signal) 
{
    if (signal == SIGABRT) {
        std::cerr << "SIGABRT received\n";
    } else {
        std::cerr << "Unexpected signal " << signal << " received\n";
    }
    std::_Exit(EXIT_FAILURE);
}
 
int main()
{
    Tester automatic_tester; // Destructor not called
 
    // Setup handler
    auto previous_handler = std::signal(SIGABRT, signal_handler);
    if (previous_handler == SIG_ERR) {
        std::cerr << "Setup failed\n";
        return EXIT_FAILURE;
    }
 
    std::abort();  // Raise SIGABRT
    std::cout << "This code is unreachable\n";
}
/*
Tester ctor
Tester ctor
SIGABRT received
*/
```

# C++14

## std::for_each

``` cpp
#include <map>
#include <algorithm>

int main()
{
    std::map<int, int> m { {1,1}, {2,2}, {3,3} };
    std::cout << m.size() << std::endl; // 3
    
    for (auto cur = m.begin(); cur != m.end();) {
        
        if (cur->first == 1 || cur->first == 3) {
            cur = m.erase(cur);
        } else {
            ++cur;
        }
    }
    std::cout << m.size() << std::endl; // 1
    std::for_each(m.begin(), m.end(), [](const auto& pair) {std::cout << pair.first << std::endl;}); // 2
}
```

* https://en.cppreference.com/w/cpp/algorithm/for_each

# C++17

## [Constexpr If](https://en.cppreference.com/w/cpp/language/if)

* Conditionally executes another statement. Used where code needs to be executed based on a `run-time` or `compile-time` condition.

``` cpp
#include <iostream>

template <typename T>
auto get_value(T t) {
    if constexpr (std::is_pointer_v<T>) {
        std::cout << "if constexpr\n";
        return *t; // deduces return type to int for T = int*
    }
    else {
        std::cout << "other\n";
        return t;  // deduces return type to int for T = int
    }
}

int main()
{
  	int a = 1;
    int *b = &a;
	std::cout << get_value(a) << std::endl;
    std::cout << get_value(b) << std::endl;
}
/*
other
1
if constexpr
1
*/
```

使用[cppinsights](https://cppinsights.io/)实例化后的代码：

``` cpp
#include <iostream>

template <typename T>
auto get_value(T t) {
    if constexpr (std::is_pointer_v<T>) {
        std::cout << "if constexpr\n";
        return *t; // deduces return type to int for T = int*
    }
    else {
        std::cout << "other\n";
        return t;  // deduces return type to int for T = int
    }
}

#ifdef INSIGHTS_USE_TEMPLATE
template<>
int get_value<int>(int t)
{
  if constexpr(false) {
  } else /* constexpr */ {
    std::operator<<(std::cout, "other\n");
    return t;
  } 
  
}
#endif

#ifdef INSIGHTS_USE_TEMPLATE
template<>
int get_value<int *>(int * t)
{
  if constexpr(true) {
    std::operator<<(std::cout, "if constexpr\n");
    return *t;
  } 
  
}
#endif

int main()
{
  int a = 1;
  int * b = &a;
  std::cout.operator<<(get_value(a)).operator<<(std::endl);
  std::cout.operator<<(get_value(b)).operator<<(std::endl);
}

```

## maybe_unused

``` cpp
#include <cassert>
 
[[maybe_unused]] void f([[maybe_unused]] bool thing1,
                        [[maybe_unused]] bool thing2)
{
   [[maybe_unused]] bool b = thing1 && thing2;
   assert(b); // in release mode, assert is compiled out, and b is unused
              // no warning because it is declared [[maybe_unused]]
} // parameters thing1 and thing2 are not used, no warning
 
int main() {;}
```

* https://en.cppreference.com/w/cpp/language/attributes/maybe_unused
# C++20

## std::source_location

The `source_location` class represents certain information about the source code, such as file names, line numbers, and function names. Previously, functions that desire to obtain this information about the call site (for logging, testing, or debugging purposes) must use macros so that predefined macros like `__LINE__` and` __FILE__` are expanded in the context of the caller. The source_location class provides a better alternative.

gcc 11.1.0

``` cpp
#include <iostream>
#include <string_view>
#include <source_location>
 
void log(const std::string_view message,
         const std::source_location location = 
               std::source_location::current())
{
    std::cout << "file: "
              << location.file_name() << "("
              << location.line() << ":"
              << location.column() << ") `"
              << location.function_name() << "`: "
              << message << '\n';
}
 
template <typename T> void fun(T x)
{
    log(x);
}
 
int main(int, char*[])
{
    log("Hello world!");
    fun("Hello C++20!");
}
/*
file: prog.cc(24:8) `int main(int, char**)`: Hello world!
file: prog.cc(19:8) `void fun(T) [with T = const char*]`: Hello C++20!
*/
```

* https://en.cppreference.com/w/cpp/utility/source_location


# Clang-Format Style Options

https://clang.llvm.org/docs/ClangFormatStyleOptions.html

	
	