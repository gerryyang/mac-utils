---
layout: post
title:  "CPP Trick"
date:   2020-05-28 20:00:00 +0800
categories: [C/C++]
---

* Do not remove this line (it will not be displayed)
{: toc}


# 优雅访问并修改C++中私有成员的方法

方法1：

``` cpp
#include <iostream>

#define private public
#include <memory>
#undef private

int main() {
  std::shared_ptr<int> a;
  a._M_refcount;  // gcc, access private member
}
```

方法2：

原理：获取成员指针，通过成员指针进行访问。

1. 类成员变量指针是个常量，比如`&C::member`是个常量，类型是`int C::*`。
2. 模板实例化不检查参数的访问属性，因此模板实例化时模板参数可以传递私有成员的指针。
3. 在模板类里就地定义友员，从而通过模板参数偷取了成员指针。

> 17.7.2 Explicit instantiation 
> http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf
> The usual access checking rules do not apply to names used to specify explicit instantiations. [ Note: In particular, the template arguments and names used in the function declarator (including parameter types, return types and exception specifications) may be private types or objects which would normally not be accessible and the template may be a member template or member function which would not normally be accessible. — end note ]


``` cpp
#include <iostream>
#include <string>

class A {
 private:
  int member;
};

struct AccessA {
  typedef int A::*type;
  friend type FiledPtr(AccessA);
};

template <typename Tag, typename Tag::type M>
struct Rob {
  friend typename Tag::type FiledPtr(Tag) { return M; }
};

template struct Rob<AccessA, &A::member>;

int main() {
  A a;
  a.*FiledPtr(AccessA()) = 42;  // write 42 to it
  std::cout << "proof: " << a.*FiledPtr(AccessA()) << std::endl;
}
```

对上面作一些简化：

``` cpp
#include <iostream>
#include <string>

class A {
 private:
  int member;
};

int A::* FiledPtr();

template <typename Tag, int Tag::* M>
struct Rob {
  friend int A::* FiledPtr() { return M; }
};

template struct Rob<A, &A::member>;

int main() {
  A a;

  auto mp = FiledPtr(); // mp: member pointer

  a.*mp = 42;  // write 42 to it
  std::cout << "proof: " << a.*mp << std::endl;
}
```

通过全局变量把成员变量的指针暴漏出来：

``` cpp
#include <iostream>
#include <string>

class A {
 private:
  int member;
};

using mem_ptr_t = int A::*;

mem_ptr_t ptr_to_member;

template <auto kMemPtr>
struct PtrExporter {
  // Initialized prior to `main` is entered.
  inline static const int lets_initialize_global_ptr = [] {
    ptr_to_member = kMemPtr;  // `ptr_to_member` is initialized here.
    return 0;
  }();
};

// Explicit instantiatation of `PtrExporter` (hence, its member
// `lets_initialize_global_ptr`.)
//
// Lambda above is run as a result of this instantiation.
template struct PtrExporter<&A::member>;

int main() {
  // By now `ptr_to_member` is initialized.

  A a;
  a.*ptr_to_member = 42;
  std::cout << "proof: " << a.*ptr_to_member << std::endl;
}
```

其他方法：

https://github.com/martong/access_private/blob/master/include/access_private.hpp


# std::find/std::find_if

Returns **the first element** in the range **[first, last)** that satisfies specific criteria:

* `find` searches for an element equal to value
* `find_if` searches for an element for which `predicate p` returns `true`
* `find_if_not` searches for an element for which `predicate q` returns `false`

``` cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main()
{
  int n1 = 3;
  int n2 = 5;

  std::vector<int> v{0, 1, 2, 3, 4};

  auto result1 = std::find(std::begin(v), std::end(v), n1);
  auto result2 = std::find(std::begin(v), std::end(v), n2);

  if (result1 != std::end(v)) {
    std::cout << "v contains: " << n1 << '\n';
  } else {
    std::cout << "v does not contain: " << n1 << '\n';
  }

  if (result2 != std::end(v)) {
    std::cout << "v contains: " << n2 << '\n';
  } else {
    std::cout << "v does not contain: " << n2 << '\n';
  }


  std::vector<int> v2 = {3, 1, 8, 5, 0};
  // 标准库里的查找算法
  std::cout << *find_if(std::begin(v2), std::end(v2),
  [](int x) { // 匿名lambda表达式, 不需要auto赋值
    return x >= 5; // 用做算法的谓词判断条件
  })
          << std::endl; // 语句执行完, lambda表达式就不存在了


  std::string str = "001001";
  std::cout << *find_if(std::begin(str), std::end(str),
  [](char c) {
    return c == '1';
  })
          << std::endl;

  return 0;
}
/*
v contains: 3
v does not contain: 5
8
1
*/
```

[https://en.cppreference.com/w/cpp/algorithm/find](https://en.cppreference.com/w/cpp/algorithm/find)


# 输出520

规则: 用尽可能不一样的方式输出520, 代码里面不能出现5/2/0。进阶规则: 代码里面不能使用数字/字符/字符串常量。PS: `sizeof(int)`这种算常量, 因为`int a[sizeof(int)]`是合法的

方法1:

``` bash
# 请求会返回 HTTP 错误码 502 Bad Gateway
curl -s -w "%{http_code}\n" https://ifish.dev/hello | grep -o . | sort -r | tr -d "\n"
```

方法2:

``` cpp
int main()
{
#define S(n) std::to_string(n)
#define CONCAT(a, b, c) S(a)+S(b)+S(c)

        auto f = [](){
                std::cout << CONCAT(__ATOMIC_SEQ_CST, __SIZEOF_SHORT__, __FINITE_MATH_ONLY__) << std::endl;
        };
        f();

        return 0;
}
```

方法3:

``` cpp
int main()
{
    static unsigned char a;
    int v;
    a--;
    v = a;
    v++;
    v++;
    v++;
    v++;
    v++;
    cout << v+v << endl;
}
```


# static_assert 声明

作用：C++11起, 进行编译时断言检查。


``` cpp
#include <type_traits>

template <class T>
void swap(T& a, T& b)
{
        static_assert(std::is_copy_constructible<T>::value,
                        "Swap requires copying");
        static_assert(std::is_nothrow_copy_constructible<T>::value
                        && std::is_nothrow_copy_assignable<T>::value,
                        "Swap requires nothrow copy/assign");
        auto c = b;
        b = a;
        a = c;
}

template <class T>
struct data_structure
{
        static_assert(std::is_default_constructible<T>::value,
                        "Data Structure requires default-constructible elements");
};

struct no_copy
{
        no_copy ( const no_copy& ) = delete;
        no_copy () = default;
};

struct no_default
{
        no_default () = delete;
};

int main()
{
        int a, b;
        swap(a, b);

        no_copy nc_a, nc_b;
        swap(nc_a, nc_b); // 1

        data_structure<int> ds_ok;
        data_structure<no_default> ds_error; // 2
}
```

```
// 1
$g++ static_assert.cpp -std=c++11
static_assert.cpp: In instantiation of 'void swap(T&, T&) [with T = no_copy]':
static_assert.cpp:40:17:   required from here
static_assert.cpp:6:2: error: static assertion failed: Swap requires copying
  static_assert(std::is_copy_constructible<T>::value,
  ^
static_assert.cpp:8:2: error: static assertion failed: Swap requires nothrow copy/assign
  static_assert(std::is_nothrow_copy_constructible<T>::value
  ^
static_assert.cpp:11:11: error: use of deleted function 'no_copy::no_copy(const no_copy&)'
  auto c = b;
           ^
static_assert.cpp:25:2: error: declared here
  no_copy ( const no_copy& ) = delete;
  ^
```

```
// 2
$g++ static_assert.cpp -std=c++11
static_assert.cpp: In instantiation of 'struct data_structure<no_default>':
static_assert.cpp:43:29:   required from here
static_assert.cpp:19:2: error: static assertion failed: Data Structure requires default-constructible elements
  static_assert(std::is_default_constructible<T>::value,
  ^
```


refer: https://zh.cppreference.com/w/cpp/language/static_assert
