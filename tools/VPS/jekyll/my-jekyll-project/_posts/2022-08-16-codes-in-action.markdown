---
layout: post
title:  "Codes in Action"
date:   2022-08-16 20:30:00 +0800
categories: 编程语言
---

* Do not remove this line (it will not be displayed)
{:toc}


# 分布式系统唯一ID生成方案

常见方案：

1. 数据库自增长序列或字段
2. UUID。UUID (Universally Unique Identifier) 的标准型式包含 32 个 16 进制数字，以连字号分为五段，形式为8-4-4-4-12的 36 个字符(32 + 4)
    + 不易于存储。UUID太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用。示例：`550e8400-e29b-41d4-a716-446655440000`
    + 信息不安全。基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置
    + ID 作为主键时在特定的环境会存在一些问题
        - 做 DB 主键的场景下，UUID 就非常不适用。MySQL 官方有明确的建议主键要尽量越短越好，36 个字符长度的 UUID 不符合要求
        - 对 MySQL 索引不利，如果作为数据库主键，在 InnoDB 引擎下，UUID 的无序性可能会引起数据位置频繁变动，严重影响性能
    + 到目前为止业界一共有 5 种方式生成 UUID，详情见 IETF 发布的 UUID 规范 [A Universally Unique IDentifier (UUID) URN Namespace](http://www.ietf.org/rfc/rfc4122.txt)
3. Twitter 的 snowflake 算法
    + snowflake 是 Twitter 开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现可[参考代码](https://github.com/twitter/snowflake)。雪花算法支持的TPS可以达到419万左右（2^22*1000）
    + 雪花算法在工程实现上有单机版本和分布式版本。分布式版本可以参看[美团leaf算法](https://github.com/Meituan-Dianping/Leaf)
4. Redis生成ID。可以用 Redis 的原子操作 INCR 和 INCRBY 来实现
5. 利用 Zookeeper 生成唯一ID。主要通过其 znode 数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号
6. MongoDB 的 ObjectId，和 snowflake 算法类似


参考方案：

* https://www.cnblogs.com/haoxinyue/p/5208136.html
* https://tech.meituan.com/2017/04/21/mt-leaf.html (美团方案)
* https://github.com/baidu/uid-generator (百度方案)


# 圈复杂度

**圈复杂度**（**Cyclomatic complexity**，CC）也称为条件复杂度，是一种衡量代码复杂度的标准，其符号为`V(G)`。

> 麦凯布最早提出一种称为“基础路径测试”（Basis Path Testing）的软件测试方式，测试程序中的每一线性独立路径，所需的测试用例个数即为程序的圈复杂度。

**圈复杂度**可以用来衡量一个模块判定结构的复杂程度，其数量上表现为独立路径的条数，也可理解为覆盖所有的可能情况最少使用的测试用例个数。

## 圈复杂度与出错风险

程序的可能错误和高的圈复杂度有着很大关系，圈复杂度最高的模块和方法，其缺陷个数也可能最多。圈复杂度大说明程序代码的判断逻辑复杂，可能质量低，且难于测试和维护。一般来说，圈复杂度大于10的方法存在很大的出错风险。

| 圈复杂度 ｜ 代码状况 | 可测性 | 维护成本
| -- | -- | -- | --
| 1 - 10 | 清晰 | 高 | 低
| 10 - 20 | 复杂 | 中 | 中
| 20 - 30 | 非常复杂 | 低 | 高
| > 30 | 不可读 | 不可测 | 非常高

## 圈复杂度与测试

**测试驱动的开发**与**较低圈复杂度值**之间存在着紧密联系。因为在编写测试用例时，开发人员会首先考虑代码的可测试性，从而倾向编写简单的代码（因为复杂的代码难以测试）。一个好的测试用例设计经验是：**创建数量与被测代码圈复杂度值相等的测试用例，以此提升测试用例对代码的分支覆盖率**。

## 圈复杂度的计算方法

圈复杂度有两种计算方法：

* **点边计算法**：圈复杂度由程序的控制流图来计算：有向图的节点对应程序中个别的代码，而若一个程序运行后会立刻运行另一代码，则会有边连接另一代码对应的节点。E 表示控制流图中边的数量，N 表示控制流图中节点的数量。圈复杂度的计算公式为：**V(G) = E - N + 2**
* **节点判定法**：圈复杂度的计算还有另外一种更直观的方法，因为圈复杂度所反映的是“判定条件”的数量，所以圈复杂度实际上就是等于判定节点的数量再加上1。对应的计算公式为：**V(G) = P + 1**。
    - 其中 P 为判定节点数，常见的判定节点有：
        + if 语句
        + while 语句
        + for 语句
        + case 语句
        + catch 语句
        + and 和 or 布尔操作
        + ? : 三元运算符
    - 对于多分支的 case 结构或 if - else if - else 结构，统计判定节点的个数时需要特别注意：必须统计全部实际的判定节点数，也即每个 else if 语句，以及每个 case 语句，都应该算为一个判定节点。


## 降低圈复杂度的方法

常用的方法有：

* 简化、合并条件表达式
* 将条件判定提炼出独立函数
* 将大函数拆成小函数
* 以明确函数取代参数
* 替换算法


refer:

* https://zhuanlan.zhihu.com/p/139386961



# Refer


* https://github.com/chen3feng/article





