---
layout: post
title:  "Compilers System"
date:   2021-10-31 11:30:00 +0800
categories: [GCC/Clang]
---

* Do not remove this line (it will not be displayed)
{:toc}


# Make (GNU make utility to maintain groups of programs)

The `make` utility will determine automatically which pieces of a large program need to be recompiled, and issue the commands to recompile them. The manual describes the GNU implementation of make, which was written by Richard Stallman and Roland McGrath, and is currently maintained by Paul Smith. Our examples show C programs, since they are very common, but you can use make with any programming language whose compiler can be run with a shell command. In fact, make is not limited to programs. You can use it to describe any task where some files must be updated automatically from others whenever the others change.

To prepare to use make, you must write a file called the `makefile` that describes the relationships among files in your program, and the states the commands for updating each file. In a program, typically the executable file is updated from object files, which are in turn made by compiling source files.

Once a suitable makefile exists, each time you change some source files, this simple shell command: `make`  suffices to perform all necessary recompilations. The make program uses the makefile description and the last-modification times of the files to decide which of the files need to be updated. For each of those files, it issues the commands recorded in the `makefile`.

`make` executes commands in the `makefile` to update one or more target names, where name is typically a program.  If no `-f` option is present, make will look for the makefiles `GNUmakefile`, `makefile`, and `Makefile`, **in that order**.

Normally you should call your makefile either **makefile** or **Makefile**.  (We recommend **Makefile** because it appears prominently near the beginning of a directory listing, right near other important files such as README.)  The first name checked, **GNUmakefile**, is not recommended for most makefiles. You should use this name if you have a makefile that is specific to GNU make, and will not be understood by other versions of make. If makefile is '-', the standard input is read.

`make` updates a target if it depends on **prerequisite files that have been modified since the target was last modified**, or **if the target does not exist**.


refer:

* https://man7.org/linux/man-pages/man1/make.1.html
* [GNU make](https://www.gnu.org/software/make/manual/make.html)
* [Automatic-Variables](https://www.gnu.org/software/make/manual/make.html#Automatic-Variables)


# Ninja (a small build system with a focus on speed)

[Ninja](https://ninja-build.org/) is a small build system with a focus on speed. It differs from other build systems in two major respects: it is designed to have its input files generated by a higher-level build system, and it is designed to run builds as fast as possible.

对比使用`ninja`和`make`编译[llvm-project-11.0.0.tar.xz](https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/llvm-project-11.0.0.tar.xz) ：

> 结论：

* `ninja`在高并发时表现出色，因此对于编译性能要求很高的场景，建议使用`ninja`构建系统。
* 在上文的llvm-project对比测试中，同样由cmake生成编译脚本（`-G Ninja`, `-G "Unix Makefiles"`）的情况下，`ninja`表现明显优于`Makefile`。


测试脚本：

```
#!/bin/bash

rm -rf build
mkdir -p build && cd build

export LLVM_INSTALL_DIR=$HOME/compile/test/install

COMPILE_MODE=gcc
#COMPILE_MODE=clang

## use `ccmake .` to use cmake gui
if [ $COMPILE_MODE == "gcc"  ]; then
        export CC=/opt/rh/devtoolset-7/root/usr/bin/cc
        export CXX=/opt/rh/devtoolset-7/root/usr/bin/c++

        ## ninja
        cmake -G "Ninja" -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS="clang;libcxx;libcxxabi;libunwind;lldb;compiler-rt;lld" -DCMAKE_INSTALL_PREFIX=$LLVM_INSTALL_DIR ../llvm-project-11.0.0/llvm

        ## makefile
        #cmake -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS="clang;libcxx;libcxxabi;libunwind;lldb;compiler-rt;lld" -DCMAKE_INSTALL_PREFIX=$LLVM_INSTALL_DIR ../llvm-project-11.0.0/llvm


elif [ $COMPILE_MODE == "clang" ]; then

        export CC=/root/compile/llvm_install/bin/clang
        export CXX=/root/compile/llvm_install/bin/clang++

        cmake -G "Ninja" -fuse-ld=lld  -DCMAKE_USER_MAKE_RULES_OVERRIDE=./ClangOverrides.txt  -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS="clang;libcxx;libcxxabi;libunwind;lldb;compiler-rt;lld" -DCMAKE_INSTALL_PREFIX=$LLVM_INSTALL_DIR ../llvm-project-11.0.0/llvm
        #cmake -G "Ninja" -fuse-ld=lld  -DCMAKE_TOOLCHAIN_FILE=./LinuxToolchains.cmake  -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS="clang;libcxx;libcxxabi;libunwind;lldb;compiler-rt;lld" -DCMAKE_INSTALL_PREFIX=$LLVM_INSTALL_DIR ../llvm-project-11.0.0/llvm

else
        echo "error: $COMPILE_MODE invalid"
        exit 1
fi

## 8 cpu, 16G mem
/usr/bin/time -f "real %e user %U sys %S" ninja -j8 -v
#/usr/bin/time -f "real %e user %U sys %S" ninja -j256

## LLD leaves its name and version number to a .comment section in an output
## readelf --string-dump .comment <output-file>

echo "have done"
```

## ninja + gcc

```
top - 21:08:49 up 181 days, 16 min,  4 users,  load average: 8.18, 8.43, 16.17
Tasks: 193 total,  10 running, 183 sleeping,   0 stopped,   0 zombie
%Cpu0  : 92.7 us,  7.3 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  : 96.7 us,  3.3 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu2  : 97.3 us,  2.7 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu3  : 96.7 us,  3.3 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu4  : 97.3 us,  2.7 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu5  : 90.3 us,  9.7 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu6  : 96.3 us,  3.7 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu7  : 92.7 us,  7.3 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 16165976 total,  7329180 free,  4121088 used,  4715708 buff/cache
KiB Swap:        0 total,        0 free,        0 used. 11429800 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
19664 root      20   0  700252 652588   8600 R  99.7  4.0   0:07.02 cc1plus
19684 root      20   0  446644 397780   6464 R  99.7  2.5   0:03.94 cc1plus
19687 root      20   0  450332 402040   6400 R  99.7  2.5   0:03.84 cc1plus
19677 root      20   0  665556 615736   6476 R  99.3  3.8   0:05.49 cc1plus
19681 root      20   0  505488 457364   6452 R  98.7  2.8   0:04.45 cc1plus
19691 root      20   0  444044 394996   6404 R  97.0  2.4   0:03.17 cc1plus
19695 root      20   0  304324 254396   6028 R  47.2  1.6   0:01.42 cc1plus
19699 root      20   0  149372 102168   5920 R  20.3  0.6   0:00.61 cc1plus
```

results:

```
$time ninja -j8

real    40m26.115s
user    301m22.380s
sys     14m17.540s
```

增加`ninja`并发可以增加速度，但是需要有较大的内存。以下为256并发时内存空间已不足，编译时会报内部错误。


```
[71/6710] Building CXX object lib/Support/CMakeFiles/LLVMSupport.dir/Debug.cpp.o
FAILED: lib/Support/CMakeFiles/LLVMSupport.dir/Debug.cpp.o
/opt/rh/devtoolset-7/root/usr/bin/c++  -DGTEST_HAS_RTTI=0 -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -Ilib/Support -I/root/compile/test/llvm-project-11.0.0/llvm/lib/Support -Iinclude -I/root/compile/test/llvm-project-11.0.0/llvm/include -fPIC -fvisibility-inlines-hidden -Werror=date-time -Wall -Wextra -Wno-unused-parameter -Wwrite-strings -Wcast-qual -Wno-missing-field-initializers -pedantic -Wno-long-long -Wimplicit-fallthrough -Wno-maybe-uninitialized -Wno-noexcept-type -Wdelete-non-virtual-dtor -Wno-comment -fdiagnostics-color -ffunction-sections -fdata-sections -O3 -DNDEBUG   -std=c++14  -fno-exceptions -fno-rtti -MD -MT lib/Support/CMakeFiles/LLVMSupport.dir/Debug.cpp.o -MF lib/Support/CMakeFiles/LLVMSupport.dir/Debug.cpp.o.d -o lib/Support/CMakeFiles/LLVMSupport.dir/Debug.cpp.o -c /root/compile/test/llvm-project-11.0.0/llvm/lib/Support/Debug.cpp
c++: internal compiler error: Killed (program cc1plus)
Please submit a full bug report,
with preprocessed source if appropriate.
See <http://bugzilla.redhat.com/bugzilla> for instructions.
```

```
top - 23:38:58 up 181 days,  2:46,  4 users,  load average: 101.87, 24.81, 8.97
Tasks: 693 total, 105 running, 587 sleeping,   0 stopped,   1 zombie
%Cpu(s): 18.0 us, 17.8 sy,  0.0 ni,  0.2 id, 63.9 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 16165976 total,   157708 free, 15388396 used,   619872 buff/cache
KiB Swap:        0 total,        0 free,        0 used.   183040 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
   64 root      20   0       0      0      0 R  27.8  0.0   3:15.14 kswapd0
    7 root      rt   0       0      0      0 S  15.2  0.0   1:25.26 migration/0
   22 root      rt   0       0      0      0 S  14.8  0.0   1:20.00 migration/3
12958 root      20   0       0      0      0 Z   5.1  0.0   4:09.43 base_agent_net
15647 root      20   0   84008  35320    896 D   3.3  0.2   0:00.31 cc1plus
26692 root      20   0  286276   4072      0 D   3.0  0.0  72:34.73 sap1012
15430 root      20   0  109000  60828   2428 D   2.9  0.4   0:00.48 cc1plus
15158 root      20   0  166464 116372   1908 R   2.7  0.7   0:00.86 cc1plus
15470 root      20   0   99312  49680    356 R   2.6  0.3   0:00.41 cc1plus
15532 root      20   0   99356  49384    360 R   2.6  0.3   0:00.37 cc1plus
```

## makefile + gcc

TODO


refer:

* [Replacing Make with Ninja](https://jpospisil.com/2014/03/16/replacing-make-with-ninja.html)
* [Ninja, a small build system with a focus on speed](https://martine.github.io/ninja)  (homepage)
* [The Performance of Open Source Software, Ninja](https://www.aosabook.org/en/posa/ninja.html)
* [Ninja, a new build system](http://neugierig.org/software/chromium/notes/2011/02/ninja.html)


# LLVM

The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Despite its name, LLVM has little to do with traditional virtual machines. The name "LLVM" itself is not an acronym; it is the full name of the project.

The primary sub-projects of LLVM are:

1. The **LLVM Core** libraries provide a modern source- and target-independent [optimizer](https://llvm.org/docs/Passes.html), along with [code generation support](https://llvm.org/docs/CodeGenerator.html) for many popular CPUs (as well as some less common ones!) These libraries are built around a [well specified](https://llvm.org/docs/LangRef.html) code representation known as the LLVM intermediate representation ("LLVM IR"). The LLVM Core libraries are [well documented](https://llvm.org/docs/), and it is particularly easy to invent your own language (or port an existing compiler) to use [LLVM as an optimizer and code generator](https://llvm.org/docs/tutorial/).

2. [Clang](https://clang.llvm.org/) is an "LLVM native" C/C++/Objective-C compiler, which aims to deliver amazingly fast compiles, extremely useful [error and warning messages](https://clang.llvm.org/diagnostics.html) and to provide a platform for building great source level tools. The [Clang Static Analyzer](https://clang-analyzer.llvm.org/) and [clang-tidy](https://clang.llvm.org/extra/clang-tidy/) are tools that automatically find bugs in your code, and are great examples of the sort of tools that can be built using the Clang frontend as a library to parse C/C++ code.

3. The [LLDB](https://lldb.llvm.org/) project builds on libraries provided by LLVM and Clang to provide a great native debugger. It uses the Clang ASTs and expression parser, LLVM JIT, LLVM disassembler, etc so that it provides an experience that "just works". It is also blazing fast and much more memory efficient than GDB at loading symbols.

4. The [libc++](https://libcxx.llvm.org/) and [libc++ ABI](https://libcxxabi.llvm.org/) projects provide a standard conformant and high-performance implementation of the C++ Standard Library, including full support for `C++11` and `C++14`.

5. The [compiler-rt](https://compiler-rt.llvm.org/) project provides highly tuned implementations of the low-level code generator support routines like "__fixunsdfdi" and other calls generated when a target doesn't have a short sequence of native instructions to implement a core IR operation. It also provides implementations of run-time libraries for dynamic testing tools such as [AddressSanitizer](https://clang.llvm.org/docs/AddressSanitizer.html), [ThreadSanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html), [MemorySanitizer](https://clang.llvm.org/docs/MemorySanitizer.html), and [DataFlowSanitizer](https://clang.llvm.org/docs/DataFlowSanitizer.html).

6. The [LLD](https://lld.llvm.org/) project is a new linker. That is a drop-in replacement for system linkers and runs much faster.

More: https://llvm.org/


## [Building LLVM with CMake](http://llvm.org/docs/CMake.html#building-llvm-with-cmake)

[CMake](http://www.cmake.org/) is a cross-platform build-generator tool. CMake does not build the project, it generates the files needed by your build tool (GNU make, Visual Studio, Xcode, etc.) for building LLVM.

编译时问题：

* Host GCC version must be at least 5.1 (使用 `scl enable devtoolset-7 bash` 切换高版本的gcc)
* `-DLLVM_ENABLE_PROJECTS`已经废弃，改为`-DLLVM_ENABLE_RUNTIMES`
* `Could NOT find Python3`，需要安装`Python3`
* 执行 `sudo yum groupinstall 'Development Tools'` 安装需要的依赖  refer: [Can't Install build-essential on CentOS](https://unix.stackexchange.com/questions/16422/cant-install-build-essential-on-centos)
* 编译错误可以查看日志：`build/CMakeFiles/CMakeError.log`

make.sh


```
#!/bin/bash

export LLVM_DIR=$HOME/llvm
export LLVM_INSTALL_DIR=$HOME/llvm/install

mkdir -p $LLVM_INSTALL_DIR
cd $LLVM_DIR

git clone https://github.com/llvm/llvm-project llvm-project
mkdir build
cd build

## -DCMAKE_BUILD_TYPE=type — Valid options for type are Debug, Release, RelWithDebInfo, and MinSizeRel. Default is Debug
## -DCMAKE_INSTALL_PREFIX=directory — Specify for directory the full pathname of where you want the LLVM tools and libraries to be installed (default /usr/local)

cmake -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=On -DLLVM_TARGETS_TO_BUILD='X86' -DLLVM_ENABLE_PROJECTS="clang;libcxx;libcxxabi;libunwind;lldb;compiler-rt;lld" -DCMAKE_INSTALL_PREFIX=$LLVM_INSTALL_DIR ../llvm-project/llvm

## The --build option tells cmake to invoke the underlying build tool (make, ninja, xcodebuild, msbuild, etc.)
cmake --build .

## After LLVM has finished building, install it from the build directory
cmake --build . --target install
```

CMakeLists.txt

```
cmake_minimum_required(VERSION 3.13.4)
project(SimpleProject)

find_package(LLVM REQUIRED CONFIG)

message(STATUS "Found LLVM ${LLVM_PACKAGE_VERSION}")
message(STATUS "Using LLVMConfig.cmake in: ${LLVM_DIR}")

# Set your project compile flags.
# E.g. if using the C++ header files
# you will need to enable C++11 support
# for your compiler.

include_directories(${LLVM_INCLUDE_DIRS})
add_definitions(${LLVM_DEFINITIONS})

# Now build our tools
add_executable(simple-tool tool.cpp)

# Find the libraries that correspond to the LLVM components
# that we wish to use
llvm_map_components_to_libnames(llvm_libs support core irreader)

# Link against LLVM libraries
target_link_libraries(simple-tool ${llvm_libs})

```


refer:

* [Embedding LLVM in your project](http://llvm.org/docs/CMake.html#embedding-llvm-in-your-project)
* [LLVM Pass入门导引](https://zhuanlan.zhihu.com/p/122522485)


## Clang (C Language Family Front-end)

> LLVM is very demanding(严格的) of the host C++ compiler, and as such tends to expose bugs in the compiler. We also attempt to follow improvements and developments in the C++ language and library reasonably closely. As such, we require a modern host C++ toolchain, both compiler and standard library, in order to build LLVM. LLVM is written using the subset of C++ documented in [coding standards](https://llvm.org/docs/CodingStandards.html).

`Clang` is a compiler front-end for the C family of languages(C, C++, Objective-C, and Objective-C++) which is built as part of the `LLVM` compiler infrastructure project.

Unlike many other compiler frontends, `Clang` is useful for a number of things beyond just compiling code: we intend for Clang to be host to a number of different source-level tools. One example of this is the Clang Static Analyzer.

If you're interested in more (including how to build Clang) it is best to read the relevant web sites. Here are some pointers:

Information on Clang:             http://clang.llvm.org/
Building and using Clang:         http://clang.llvm.org/get_started.html
Clang Static Analyzer:            http://clang-analyzer.llvm.org/
Information on the LLVM project:  http://llvm.org/

`Clang` is released as part of regular LLVM releases. You can download the release versions from https://llvm.org/releases/. `Clang` is also provided in all major BSD or GNU/Linux distributions as part of their respective packaging systems. From Xcode 4.2, Clang is the default compiler for Mac OS X.

## Install

[Ubuntu安装Clang版本和切换](https://blog.csdn.net/DumpDoctorWang/article/details/84567757)

```
apt-get install clang
apt-get install clang-3.9
```

### Building Clang and Working with the Code

On Unix-like Systems

If you would like to check out and build `Clang`, the current procedure is as follows:

#### Get the required tools

* See [Getting Started with the LLVM System - Requirements](https://llvm.org/docs/GettingStarted.html#requirements).
* Note also that Python is needed for running the test suite. Get it at: https://www.python.org/downloads/
* Standard build process uses `CMake`. Get it at: https://cmake.org/download/

> Hardware

**Note that Debug builds require a lot of time and disk space**. An LLVM-only build will need about `1-3 GB` of space. A full build of LLVM and Clang will need around `15-20 GB` of disk space. The exact space requirements will vary by system. (It is so large because of all the debugging information and the fact that the libraries are statically linked into multiple tools).

If you are space-constrained, you can build only selected tools or only selected targets. The Release build requires considerably less space.

The LLVM suite may compile on other platforms, but it is not guaranteed to do so. If compilation is successful, the LLVM utilities should be able to assemble, disassemble, analyze, and optimize LLVM bitcode. Code generation should work as well, although the generated native code may not work on your platform.

> Software

Compiling LLVM requires that you have several software packages installed. The table below lists those required packages. The Package column is the usual name for the software package that LLVM depends on. The Version column provides “known to work” versions of the package. The Notes column describes how LLVM uses the package and provides other details.


| Package | Version | Notes
| -- | -- | --
| CMake | >=3.13.4 | Makefile/workspace generator
| GCC | >=5.1.0 |	C/C++ compiler (1)
| python | >=3.6 | Automated test suite (2)
| zlib | >=1.2.3.4 | Compression library (3)
| GNU Make |	3.79, 3.79.1	| Makefile/build processor (4)

Note:

* (1) Only the C and C++ languages are needed so there’s no need to build the other languages for LLVM’s purposes. See below for specific version info.
* (2) Only needed if you want to run the automated test suite in the llvm/test directory.
* (3) Optional, adds compression / uncompression capabilities to selected LLVM tools.
* (4) Optional, you can use any other build tool supported by CMake.


#### Check out the LLVM project

* Change directory to where you want the llvm directory placed.
* `git clone https://github.com/llvm/llvm-project.git`
* The above command is very slow. It can be made faster by creating a shallow clone. Shallow clone saves storage and speeds up the checkout time. This is done by using the command:
  + `git clone --depth=1 https://github.com/llvm/llvm-project.git` (using this only the latest version of llvm can be built)
  + For normal users looking to just compile, this command works fine. But if someone later becomes a contributor, since they can't push code from a shallow clone, it needs to be converted into a full clone:
    - `cd llvm-project`
    - `git fetch --unshallow`

#### Build LLVM and Clang

* This builds both LLVM and Clang for debug mode.
* Note: For subsequent Clang development, you can just run make clang.
* CMake allows you to generate project files for several IDEs: Xcode, Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator), KDevelop3. For more details see [Building LLVM with CMake](https://llvm.org/docs/CMake.html) page.

```
cd llvm-project
mkdir build (in-tree build is not supported)
cd build
cmake -DLLVM_ENABLE_PROJECTS=clang -G "Unix Makefiles" ../llvm
make
```

#### Others

If you intend to use Clang's C++ support, you may need to tell it how to find your C++ standard library headers. In general, Clang will detect the best version of `libstdc++` headers available and use them - it will look both for system installations of libstdc++ as well as installations adjacent to Clang itself. If your configuration fits neither of these scenarios, you can use the `-DGCC_INSTALL_PREFIX` cmake option to tell Clang where the gcc containing the desired `l`ibstdc++` is installed.

Try it out (assuming you add llvm/build/bin to your path):

```
clang --help
clang file.c -fsyntax-only (check for correctness)
clang file.c -S -emit-llvm -o - (print out unoptimized llvm code)
clang file.c -S -emit-llvm -o - -O3
clang file.c -S -O3 -o - (output native machine code)
```

Run the testsuite:

```
make check-clang
```

### Clang Compiler Driver (Drop-in Substitute for GCC)

The `clang` tool is the compiler driver and front-end, which is designed to be a drop-in replacement for the `gcc` command. Here are some examples of how to use the high-level driver:

```
$clang -v
clang version 3.5.2 (tags/RELEASE_352/final)
Target: x86_64-unknown-linux-gnu
Thread model: posix
Found candidate GCC installation: /usr/lib/gcc/x86_64-redhat-linux/4.4.7
Found candidate GCC installation: /usr/lib/gcc/x86_64-redhat-linux/4.8.2
Found candidate GCC installation: /usr/lib/gcc/x86_64-redhat-linux/4.8.5
Selected GCC installation: /usr/lib/gcc/x86_64-redhat-linux/4.8.5
Candidate multilib: .;@m64
Candidate multilib: 32;@m32
Selected multilib: .;@m64
```

```
$ cat t.c
#include <stdio.h>
int main(int argc, char **argv) { printf("hello world\n"); }
$ clang t.c
$ ./a.out
hello world
```

The clang driver is designed to work as closely to GCC as possible to maximize portability. The only major difference between the two is that Clang defaults to `gnu99` mode while GCC defaults to gnu89 mode. If you see weird link-time errors relating to inline functions, try passing `-std=gnu89` to clang.

``` c
// test.c
typedef float V __attribute__((vector_size(16)));
V foo(V a, V b)
{
    return a + b * a;
}
```

Preprocessing:

``` cpp
//$clang test.c -E
# 1 "test.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 312 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "test.c" 2

typedef float V __attribute__((vector_size(16)));

V foo(V a, V b)
{
 return a + b * a;
}
```

Type checking:

```
$clang -fsyntax-only test.c
```

GCC options:

```
$clang -fsyntax-only test.c -pedantic
```

Pretty printing from the AST:

> Note, the `-cc1` argument indicates the compiler front-end, and not the driver, should be run. The compiler front-end has several additional Clang specific features which are not exposed through the GCC compatible driver interface.

``` cpp
// $clang -cc1 test.c -ast-print
typedef __attribute__((__vector_size__(4 * sizeof(float)))) float V;
V foo(V a, V b) {
    return a + b * a;
}
```

Code generation with LLVM:


``` cpp
// $clang test.c -S -emit-llvm -o -
; ModuleID = 'test.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: nounwind uwtable
define <4 x float> @foo(<4 x float> %a, <4 x float> %b) #0 {
  %1 = alloca <4 x float>, align 16
  %2 = alloca <4 x float>, align 16
  store <4 x float> %a, <4 x float>* %1, align 16
  store <4 x float> %b, <4 x float>* %2, align 16
  %3 = load <4 x float>* %1, align 16
  %4 = load <4 x float>* %2, align 16
  %5 = load <4 x float>* %1, align 16
  %6 = fmul <4 x float> %4, %5
  %7 = fadd <4 x float> %3, %6
  ret <4 x float> %7
}

attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.ident = !{!0}

!0 = metadata !{metadata !"clang version 3.5.2 (tags/RELEASE_352/final)"}
```

refer:

* https://github.com/llvm/llvm-project/tree/main/clang
* [Getting Started: Building and Running Clang](https://clang.llvm.org/get_started.html)
* [LLVM Download Page](https://releases.llvm.org/)


## ld (The GNU linker)

> ld [options] objfile ...

`ld` combines a number of object and archive files, relocates their data and ties up symbol references. Usually the last step in compiling a program is to run `ld`.

refer: [ld(1) - Linux man page](https://linux.die.net/man/1/ld)

## ld.gold (an official GNU package)

The motivation for writing gold was to make a linker that is faster than the [GNU linker](https://en.wikipedia.org/wiki/GNU_linker), especially for large applications coded in C++.

```
# use ld.gold instead of ld for performance
SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fuse-ld=gold")

# get link stage stats
SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,--stats")
SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,--stats")
```

* [gold (linker)](https://en.wikipedia.org/wiki/Gold_%28linker%29)
* [Replacing ld with gold - any experience?](https://stackoverflow.com/questions/3476093/replacing-ld-with-gold-any-experience)


## lld (The LLVM Linker)

Replace `ld` to `lld`:

```
# orig: /opt/rh/devtoolset-7/root/etc/alternatives/ld -> /opt/rh/devtoolset-7/root/usr/bin/ld.bfd
# ln -s /opt/rh/devtoolset-7/root/usr/bin/ld.bfd /opt/rh/devtoolset-7/root/etc/alternatives/ld
#
rm /opt/rh/devtoolset-7/root/etc/alternatives/ld
ln -s /root/compile/llvm_install/bin/ld.lld /opt/rh/devtoolset-7/root/etc/alternatives/ld

ls -l /opt/rh/devtoolset-7/root/etc/alternatives/ld
lrwxrwxrwx 1 root root 37 Dec 13 16:47 /opt/rh/devtoolset-7/root/etc/alternatives/ld -> /root/compile/llvm_install/bin/ld.lld
```

LLD leaves its name and version number to a `.comment` section in an output. If you are in doubt whether you are successfully using LLD or not, run `readelf --string-dump .comment <output-file>` and examine the output. If the string “Linker: LLD” is included in the output, you are using LLD.

```
$readelf --string-dump .comment demo

String dump of section '.comment':
  [     0]  Linker: LLD 12.0.0 (/root/compile/llvm-project/lld f76b7f22f085fbf9f2585923f7a3a0558d75964b)
  [    5d]  clang version 12.0.0 (/root/compile/llvm-project/clang f76b7f22f085fbf9f2585923f7a3a0558d75964b)
  [    be]  GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-4)
  [    ea]  GCC: (GNU) 7.3.1 20180303 (Red Hat 7.3.1-5)
```

refer:

* [LLD - The LLVM Linker](https://lld.llvm.org/#lld-the-llvm-linker)



# CCache (a fast C/C++ compiler cache)

`ccache` is a compiler cache. It speeds up recompilation by caching the result of previous compilations and detecting when the same compilation is being done again. Supported languages are C, C++, Objective-C and Objective-C++.

`ccache` has been carefully written to always produce exactly the same compiler output that you would get without the cache. The only way you should be able to tell that you are using `ccache` is the speed. Currently known exceptions to this goal are listed under CAVEATS. If you ever discover an undocumented case where ccache changes the output of your compiler, please let us know.

There are two ways to use ccache. You can either **prefix your compilation commands with ccache** or you can **let ccache masquerade as the compiler by creating a symbolic link (named as the compiler) to ccache**. The first method is most convenient if you just want to try out ccache or wish to use it for some specific projects. The second method is most useful for when you wish to use ccache for all your compilations.

To use the first method, just make sure that `ccache` is in your `PATH`.

To use the symlinks method, do something like this:

```
cp ccache /usr/local/bin/
ln -s ccache /usr/local/bin/gcc
ln -s ccache /usr/local/bin/g++
ln -s ccache /usr/local/bin/cc
ln -s ccache /usr/local/bin/c++
```

And so forth. This will work as long as the directory with symlinks comes before the path to the compiler (which is usually in `/usr/bin`). After installing you may wish to run “which gcc” to make sure that the correct link is being used.

* Features
  + Keeps statistics on hits/misses.
  + Automatic cache size management.
  + Can cache compilations that generate warnings.
  + Easy installation.
  + Low overhead.
  + Optionally compresses files in the cache to reduce disk space.

* Limitations
  + Only knows how to cache the compilation of a single C/C++/Objective-C/Objective-C++ file. Other types of compilations (multi-file compilation, linking, etc) will silently fall back to running the real compiler.
  + Only works with GCC and compilers that behave similar enough.
  + Some compiler flags are not supported. If such a flag is detected, ccache will silently fall back to running the real compiler.

More: man ccache


```
$which gcc
/usr/lib64/ccache/gcc
$ll -lh `which gcc`
lrwxrwxrwx 1 root root 16 3月   5 2021 /usr/lib64/ccache/gcc -> ../../bin/ccache
$ll -lh /usr/bin/ccache
-rwxr-xr-x 1 root root 135K 2月  19 2020 /usr/bin/ccache
```

* [https://ccache.dev/](https://ccache.dev/)
* [ccache 4.8.2](https://ccache.dev/manual/4.8.2.html)
* https://github.com/ccache/ccache/blob/master/README.md
* https://github.com/ccache/ccache/blob/master/doc/INSTALL.md
* [ccache and clang, part 3](http://peter.eisentraut.org/blog/2014/12/01/ccache-and-clang-part-3/)



# 编译效率对比

在8核CPU，16G内存机器，对比`gcc`, `clang`, `make`, `ninja`, `ld`, `lld`不同组合情况下的编译效率。

[测试代码](https://github.com/gerryyang/mac-utils/tree/master/tools/CMake/helloworld)


* 使用`CMake`生成`Unix Makefiles`，分别指定不同的`gcc`或者`clang`版本编译构建：(make.sh)
* 使用`CMake`生成`Ninja`，分别指定不同的`gcc`或者`clang`版本编译构建：(ninja.sh)
* 对比不同链接器`ld`，`lld`的性能差异

make.sh

``` bash
#!/bin/bash

## https://stackoverflow.com/questions/7031126/switching-between-gcc-and-clang-llvm-using-cmake

rm -rf build
mkdir -p build && cd build

COMPILE_MODE=gcc
#COMPILE_MODE=clang

## use `ccmake .` to use cmake gui
if [ $COMPILE_MODE == "gcc"  ]; then
        export CC=/opt/rh/devtoolset-7/root/usr/bin/cc
        export CXX=/opt/rh/devtoolset-7/root/usr/bin/c++

        cmake -G "Unix Makefiles" -DCMAKE_USER_MAKE_RULES_OVERRIDE=./GccOverrides.txt  ..

elif [ $COMPILE_MODE == "clang" ]; then

        #export CC=/root/compile/llvm_install/bin/clang
        #export CXX=/root/compile/llvm_install/bin/clang++

        export CC=/usr/local/bin/clang
        export CXX=/usr/local/bin/clang++

        cmake -G "Unix Makefiles" -fuse-ld=lld  -DCMAKE_USER_MAKE_RULES_OVERRIDE=./ClangOverrides.txt  ..
        #cmake -G "Unix Makefiles" -fuse-ld=lld  -DCMAKE_TOOLCHAIN_FILE=./ClangToolchains.cmake  ..

else
        echo "error: $COMPILE_MODE invalid"
        exit 1
fi

/usr/bin/time -f "real %e user %U sys %S" make -j8 VERBOSE=1

## LLD leaves its name and version number to a .comment section in an output
## readelf --string-dump .comment <output-file>

echo "have done"
```

ninja.sh

``` bash
#!/bin/bash

## https://stackoverflow.com/questions/7031126/switching-between-gcc-and-clang-llvm-using-cmake

rm -rf build
mkdir -p build && cd build

COMPILE_MODE=gcc
#COMPILE_MODE=clang

## use `ccmake .` to use cmake gui
if [ $COMPILE_MODE == "gcc"  ]; then
        export CC=/opt/rh/devtoolset-7/root/usr/bin/cc
        export CXX=/opt/rh/devtoolset-7/root/usr/bin/c++

        cmake -G "Ninja" -DCMAKE_USER_MAKE_RULES_OVERRIDE=./GccOverrides.txt  ..

elif [ $COMPILE_MODE == "clang" ]; then

        #export CC=/root/compile/llvm_install/bin/clang
        #export CXX=/root/compile/llvm_install/bin/clang++

        export CC=/usr/local/bin/clang
        export CXX=/usr/local/bin/clang++

        cmake -G "Ninja" -fuse-ld=lld  -DCMAKE_USER_MAKE_RULES_OVERRIDE=./ClangOverrides.txt  ..
        #cmake -G "Ninja" -fuse-ld=lld  -DCMAKE_TOOLCHAIN_FILE=./ClangToolchains.cmake  ..

else
        echo "error: $COMPILE_MODE invalid"
        exit 1
fi

/usr/bin/time -f "real %e user %U sys %S" ninja -j8 -v

## LLD leaves its name and version number to a .comment section in an output
## readelf --string-dump .comment <output-file>

echo "have done"
```


测试结果：

clang12 优于 gcc4.8/7/9，ninja 优于 make，lld 优于 ld。

| Case                  | Time   |
| --------------------- | ------ |
| gcc7 + make + ld      | 25.7s  |
| clang12 + make + ld   | 5.2s   |
| gcc7 + ninja + ld     | 22s    |
| clang12 + ninja + ld  | 4.7s   |
| gcc7 + make + lld     | 17.8s  |
| clang12 + make + lld  | 4.82s  |
| gcc7 + ninja + lld    | 18.34s |
| clang12 + ninja + lld | 4.15s  |
| gcc9 + make + lld     | 10.03s |
| gcc9 + ninja + lld    | 7.90s  |
| gcc4.8 + make + lld   | 8.93s  |
| gcc4.8 + ninja + lld  | 8.30s  |

# Mixing Clang with GCC

## [Can Clang compile code with GCC compiled .a libs?](https://stackoverflow.com/questions/20875924/can-clang-compile-code-with-gcc-compiled-a-libs)

I have my project currently compiling under `gcc`. It uses Boost, ZeroMQ as static `.a` libraries and some `.so` libraries like SDL. I want to go `clang` all the way but not right now. I wonder if it is possible to compile code that uses `.a` and `.so` libraries that were compiled under gcc with clang?

Answers:

Yes, you usually can use `clang` with `GCC` compiled libraries (and vice versa, use `gcc` with `CLANG` compiled libraries), because in fact it is not **compilation**(编译) but **linking**(链接) which is relevant. You might be unlucky and get unpleasant suprises.

You could in principle have some dependencies on the version of `libstdc++` used to link the relevant libraries (if they are coded in C++). Actually, that usually does not matter much.

In C++, [name mangling](http://en.wikipedia.org/wiki/Name_mangling) might in theory be an issue (there might be some corner cases, even incompatibilities between two different versions of `g++`). Again, in practice it is usually not an issue.

So usually you can mix `CLANG` (even different but close versions of it) with `GCC` **but you may have unpleasant surprises**. **What should be expected from any C++ compiler (be it `CLANG` or `GCC`) is just to be able to compile and link an entire software (and all libraries) together using the same compiler and version (and that includes the same [C++ standard library](https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library) implementation). This is why upgrading a compiler in a distribution is a lot of work**: the distribution makers have to ensure that all the packages compile well (and they do get surprises!).

Beware that the version of `libstdc++` does matter. Both `Clang` & `GCC` communities **work hard to make its ABI compatible for compiler upgrades, but there are subtle corner cases**. Read the documentation of your particular and specific C++ standard library implementation. These corner cases could explain mysterious crashes when using a good C++ library binary (compiled with `GCC 5`) in your code compiled with `GCC 8`. The bug is not in the library, **but the ABI evolved incompatibly**.

Another answers:

At least for [Crypto++ library](http://www.cryptopp.com/) this does not work (verified :-( ). So for c++ code it is less likely to work, while pure c code would probably link OK.

The solution appears to be: **if you need to compile C++ code with clang, and link it to a gcc-compiled library**, use `clang++ -stdlib=libstdc++`. The linking is successful, and the resulting binary runs correctly.

CAVEAT(注意): It does not seem to work the other way: even though you can build a library compiled with "clang++ -stdlib=libstdc++" and link gcc-compiled code with it, this code will crash with SEGV. So far I found the only way to link with a clang-compiled library is compiling your code with clang, not gcc.

## [gcc vs clang common library issue](https://stackoverflow.com/questions/49715462/gcc-vs-clang-common-library-issue?noredirect=1&lq=1)

I have two applications, one compiled with gcc(c++) and another compiled with clang++. I am to use common shared boost library for both the applications. My question is whether to compile boost shared library using clang compiler or gcc compiler. Can I use boost library compiled with gcc in my application that is being compiled using clang?

Answers:

`g++` and `clang++` are compatible as compilers (because they both follow the `Itanium ABI`), **but they may come with incompatible standard library implementations**.

`g++` comes with a standard library implementation called `libstdc++`. You can direct g++ to use a different implementation but this is not exactly trivial.

`clang++` sometimes comes without a standard library implementation of its own (and is configured to use implementation provided by `g++`), and sometimes comes with an implementation called `libc++`. One can easily switch `clang++` to use either `libc++` or `libstdc++` with a single command line option.

**So your question boils down to what standard library implementation(s) your applications use.** If they use the same implementation, you need to build Boost with that implementation (and either compiler). If they use different implementations, you need two separate builds of Boost.

Mixing components built against different standard library implementations in the same application can sometimes be done, but is not straightforward, entails a lot of restrictions, and with things like boost is either not feasible or downright impossible.




# Refer

* [Switching between GCC and Clang/LLVM using CMake](https://stackoverflow.com/questions/7031126/switching-between-gcc-and-clang-llvm-using-cmake)



