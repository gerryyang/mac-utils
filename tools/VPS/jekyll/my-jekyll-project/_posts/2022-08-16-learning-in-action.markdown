---
layout: post
title:  "Learning in Action"
date:   2022-08-16 20:30:00 +0800
categories: 杂记
---

* Do not remove this line (it will not be displayed)
{:toc}


# ACGI

AIGC（AI-Generated Content）可以自动生成各种文本内容，如文章、新闻、产品描述、广告语等，它使用人工智能技术，通过对大量文本数据的学习和分析来生成通顺、连贯、语法正确的文本内容。对于需要大量重复性内容的场景（如电商平台的商品描述、新闻媒体的稿件生成等），它能大幅提高内容创作效率。AIGC 工具的实现方式有很多种，如基于语言模型的自动生成文本、基于模板的文本生成、基于知识图谱的自动生成文本等。随着技术的不断进步，AIGC 工具在自动生成文本方面的能力也在不断提升，能够生成更加贴近人类写作风格的文本内容。


# 分布式系统唯一ID生成方案

常见方案：

1. 数据库自增长序列或字段
2. UUID。UUID (Universally Unique Identifier) 的标准型式包含 32 个 16 进制数字，以连字号分为五段，形式为8-4-4-4-12的 36 个字符(32 + 4)
    + 不易于存储。UUID太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用。示例：`550e8400-e29b-41d4-a716-446655440000`
    + 信息不安全。基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置
    + ID 作为主键时在特定的环境会存在一些问题
        - 做 DB 主键的场景下，UUID 就非常不适用。MySQL 官方有明确的建议主键要尽量越短越好，36 个字符长度的 UUID 不符合要求
        - 对 MySQL 索引不利，如果作为数据库主键，在 InnoDB 引擎下，UUID 的无序性可能会引起数据位置频繁变动，严重影响性能
    + 到目前为止业界一共有 5 种方式生成 UUID，详情见 IETF 发布的 UUID 规范 [A Universally Unique IDentifier (UUID) URN Namespace](http://www.ietf.org/rfc/rfc4122.txt)
3. Twitter 的 snowflake 算法
    + snowflake 是 Twitter 开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现可[参考代码](https://github.com/twitter/snowflake)。雪花算法支持的TPS可以达到419万左右（2^22*1000）
    + 雪花算法在工程实现上有单机版本和分布式版本。分布式版本可以参看[美团leaf算法](https://github.com/Meituan-Dianping/Leaf)
4. Redis生成ID。可以用 Redis 的原子操作 INCR 和 INCRBY 来实现
5. 利用 Zookeeper 生成唯一ID。主要通过其 znode 数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号
6. MongoDB 的 ObjectId，和 snowflake 算法类似


参考方案：

* https://www.cnblogs.com/haoxinyue/p/5208136.html
* https://tech.meituan.com/2017/04/21/mt-leaf.html (美团方案)
* https://github.com/baidu/uid-generator (百度方案)


# 圈复杂度

**圈复杂度**（**Cyclomatic complexity**，CC）也称为条件复杂度，是一种衡量代码复杂度的标准，其符号为`V(G)`。

> 麦凯布最早提出一种称为“基础路径测试”（Basis Path Testing）的软件测试方式，测试程序中的每一线性独立路径，所需的测试用例个数即为程序的圈复杂度。

**圈复杂度**可以用来衡量一个模块判定结构的复杂程度，其数量上表现为独立路径的条数，也可理解为覆盖所有的可能情况最少使用的测试用例个数。

## 圈复杂度与出错风险

程序的可能错误和高的圈复杂度有着很大关系，圈复杂度最高的模块和方法，其缺陷个数也可能最多。圈复杂度大说明程序代码的判断逻辑复杂，可能质量低，且难于测试和维护。一般来说，圈复杂度大于10的方法存在很大的出错风险。

| 圈复杂度 | 代码状况 | 可测性 | 维护成本
| -- | -- | -- | --
| 1 - 10 | 清晰 | 高 | 低
| 10 - 20 | 复杂 | 中 | 中
| 20 - 30 | 非常复杂 | 低 | 高
| > 30 | 不可读 | 不可测 | 非常高

## 圈复杂度与测试

**测试驱动的开发**与**较低圈复杂度值**之间存在着紧密联系。因为在编写测试用例时，开发人员会首先考虑代码的可测试性，从而倾向编写简单的代码（因为复杂的代码难以测试）。一个好的测试用例设计经验是：**创建数量与被测代码圈复杂度值相等的测试用例，以此提升测试用例对代码的分支覆盖率**。

## 圈复杂度的计算方法

圈复杂度有两种计算方法：

* **点边计算法**：圈复杂度由程序的控制流图来计算：有向图的节点对应程序中个别的代码，而若一个程序运行后会立刻运行另一代码，则会有边连接另一代码对应的节点。E 表示控制流图中边的数量，N 表示控制流图中节点的数量。圈复杂度的计算公式为：**V(G) = E - N + 2**
* **节点判定法**：圈复杂度的计算还有另外一种更直观的方法，因为圈复杂度所反映的是“判定条件”的数量，所以圈复杂度实际上就是等于判定节点的数量再加上1。对应的计算公式为：**V(G) = P + 1**。
    - 其中 P 为判定节点数，常见的判定节点有：
        + if 语句
        + while 语句
        + for 语句
        + case 语句
        + catch 语句
        + and 和 or 布尔操作
        + ? : 三元运算符
    - 对于多分支的 case 结构或 if - else if - else 结构，统计判定节点的个数时需要特别注意：必须统计全部实际的判定节点数，也即每个 else if 语句，以及每个 case 语句，都应该算为一个判定节点。


## 降低圈复杂度的方法

常用的方法有：

* 简化、合并条件表达式
* 将条件判定提炼出独立函数
* 将大函数拆成小函数
* 以明确函数取代参数
* 替换算法


refer:

* https://zhuanlan.zhihu.com/p/139386961


# OAuth 2.0 (授权)

[OAuth](https://en.wikipedia.org/wiki/OAuth) 是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是 2.0 版。OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。

简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。

令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。

1. 令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。
2. 令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。
3. 令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。

上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。

注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。

* [理解 OAuth 2.0](https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)
* [OAuth 2.0 的一个简单解释](https://www.ruanyifeng.com/blog/2019/04/oauth_design.html)


# 软件设计原则

软件设计原则，说到底不外乎，**模块内高内聚，模块间去耦合**。下面是学院派总结的一些原则。

![software-design-rule](/assets/images/202210/software-design-rule.png)


# KISS 原则

KISS (Keep It Simple, Stupid) 是一种归纳过的经验原则。KISS 原则是指在设计当中应当注重简约的原则。总结工程专业人员在设计过程中的经验，大多数系统的设计应保持简洁和单纯，而不掺入非必要的复杂性，这样的系统运作成效会取得最优；因此简单性应该是设计中的关键目标，尽量回避免不必要的复杂性。

# Domain-Driven Design (DDD 领域驱动设计)

在《领域驱动设计·软件核心复杂性应对之道》这本书里，对什么是“领域”，只有简单的一句话：**“每个软件程序是为了执行用户的某项活动，或是满足用户的某种需求。这些用户应用软件的问题区域就是软件的领域。”** 除此之外，讲的更多的是“模型” 或者“领域模型”，纵观全书，“Model-Driven Design” 是其核心概念之一。某种程度上，把“领域驱动设计”改为“模型驱动设计”，一点问题都没有，甚至“模型驱动设计”更能体现整本书的精髓。

总的来说，“领域”这个词可能承载了太多含义。**领域**既可以表示整个**业务系统**，也可以表示其中的**某个核心域**或者**支撑子域**。


# Metric (指标)

* `counter` 是个计数器，用于统计**累计量**。counter 主要用于统计某类指标的数量，它将保存从系统启动开始持续的累加值。支持对 counter 进行 +1, -1, +n, -n 的操作。
* `gauge` 是一个瞬时值，用于统计**时刻量**。
* `timer` 是根据一个操作的开始时间，结束时间，**统计某个操作的耗时情况**。
* `histogram` 是根据预先划分好的 buckets，将收集到的样本点放入到对应的 bucket 中，这样可以方便查看不同区间（bucket 的上下界）的样本数量，平均值，最大值，最小值等，各个区间的具体值由统计策略决定。 histogram（直方图）用于统一某类指标的分布情况，如最大，最小，平均值，标准差，以及各种分位数，例如 90%，95% 的数据分布在某个范围内。


主调监控：指的是当前服务调用下游服务请求的 client 端的监控，从发起请求到收到下游回包的监控

被调监控：指的是当前服务接收上游服务请求的 server 端的监控，从收到请求到业务逻辑结束的监控





# Refer


* https://github.com/chen3feng/article





